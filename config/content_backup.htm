<h1>About</h1>
<p><img alt="如何降低电路板的噪声| 村田中文技术社区" src="https://lh3.googleusercontent.com/proxy/u3RWOeJxufDbwWt4cGQZYnTBGdippG8WZjlkfXcpPjEpeeVYeHzxLiXoJXZiEA3o3yhK6X3E7IjeeiJfKN08AmXmK1i1XbcIV7ZTDIVXYu0jzIiZnqlgctg32D0"/></p>
<p>整個學期下來，看見了很多以前在高中沒見過的東西，所以在做作業時偶爾會遇到一些問題，以為靠自己就能解決問題嗎?並沒有，所以不是去找大腿抱不然就是找老師問問題，如果自己硬要解決的話，可能只會越搞越糟糕而已，所以我要在這感謝那些曾經讓我抱過的大腿，當初github倉儲連接不到cmsimde的網站時就是請他們幫忙，如果沒請人幫忙的話可能現在連HW1都不會出現。</p>
<p></p>
<h2>Develop</h2>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>
<h3>test</h3>
<h1>HomeWork</h1>
<h2>HW1</h2>
<h3>Overview</h3>
<p><span style="color: #3366ff;"> Expansion Slots</span></p>
<blockquote>
<p>Expansion cards are used to increase and expand a computer’s capability.</p>
<p><span style="color: #99cc00;">擴充卡用於增強和擴展計算機的功能</span><br/>Communication-based cards can also expand the feature set of the computer through adding a modem or network card.<br/><span style="color: #99cc00;">基於通信的卡還可以通過添加調製解調器或網卡來擴展計算機的功能集。</span></p>
<p>Users who want to play more games may find it useful to add a new video card with better graphics capabilities.</p>
<p><span style="color: #99cc00;">想要玩更多遊戲的用戶可能會發現添加具有更好圖形功能的新視頻卡很有用。</span><br/>However, most commonly, expansion slots are used to add new ports and new features, such as ports and features that were initially unavailable when the computer was created, such as eSATA, FireWire, or USB 3.0 ports.<br/><span style="color: #99cc00;">但是，最常見的是，擴展槽用於添加新端口和新功能，例如在創建計算機時最初不可用的端口和功能，例如eSATA，FireWire或USB 3.0端口。</span></p>
</blockquote>
<p></p>
<blockquote>
<p><span style="color: #0000ff;">PCI PCI-X Slots</span><br/>PCI was originally developed in the early 1990s to provide an expansion slot for network, video, audio, I O (input output), modem, and storage host adapter cards.<br/><span style="color: #99cc00;">PCI最初是在1990年代初開發的，旨在為網絡，視頻，音頻，I   O（輸入 輸出），調製解調器和存儲主機適配器卡提供擴展插槽。它取代了較早的技術，例如行業標準體系結構（ISA）卡，以提供更快，更強大的擴展卡插槽。</span><br/>The subsequent upgrade is called PCI-X, which is a faster 64-bit version that runs at a bus speed of 133 MHz.<br/><span style="color: #99cc00;">隨之而來的升級稱為PCI-X，它是一種更快的64位版本，以133 MHz的總線速度運行。</span><br/>This PCI-X can be found in modern computers that still have PCI PCI-X slots. It is fully backward compatible with old PCI cards, but if you mix them with newer PCI-X cards, the motherboard defaults to Slower PCI speed<br/><span style="color: #99cc00;">該PCI-X在仍然具有PCI   PCI-X插槽的現代計算機中可以找到，它與舊的PCI卡完全向後兼容，但是如果將它們與更新的PCI-X卡混合使用，則主板默認設置為較慢PCI速度</span><br/>The latest version of PCI-X 2.0 supports speeds up to 266 MHz to 533 MHz, but has been replaced by the PCIe (PCI Express) card slot standard to achieve better speed performance.<br/><span style="color: #99cc00;">最新版本的PCI-X 2.0支持最高266 MHz至533 MHz的速度，但已被PCIe（PCI Express）卡插槽標準所取代，以實現更好的速度 性能。</span><br/>Since Apple Computers and AMD chipsets, it has been a standard expansion bus. Although PCI is definitely a traditional architecture, it has been replaced by PCIe and Thunderbolt interfaces, but it is still included in current motherboards and can be found in most computer workstation services.<br/><span style="color: #99cc00;">Apple Computers和AMD芯片組以來，一直是標準的擴展總線。儘管PCI絕對是一種傳統架構，但已被PCIe和Thunderbolt接口取代，但它仍包含在當前主板中，並且可以在大多數計算機工作站的服務中找到。</span></p>
<p><span>Summary</span><br/>The PCI bus operates independently of the system bus, so that expansion cards can be used to access peripheral devices faster.<br/><span style="color: #99cc00;">PCI總線獨立於系統總線運行，從而可以使用擴展卡更快地訪問外圍設備。</span><br/>The PCI version initially uses a 32-bit data path and finally uses a 64-bit data path. The speed is as follows<br/>133 MB s (32-bit, 33 MHz-standard configuration)<br/>266 MB s (32-bit at 66 MHz or 64-bit at 33 MHz)<br/>533 MB s (64-bit at 66 MHz)<br/><span style="color: #99cc00;">PCI版本最初使用32位數據路徑，最終使用64位數據路徑，速度如下</span><br/><span style="color: #99cc00;">133 MB   s（32位，33 MHz –標準配置）</span><br/><span style="color: #99cc00;">266 MB   s（66 MHz時為32位或33 MHz時為64位）</span><br/><span style="color: #99cc00;">533 MB   s（66 MHz時為64位）</span></p>
<p><img alt="An expansion card with chips on the board and mounts. It is held in a person’s hand." src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image1.png"/></p>
</blockquote>
<h3>AGP Slots (AGP插槽)</h3>
<blockquote>
<p><span lang="zh-TW">AGP was dominant for a long period of time, but the introduction of PCIe (PCI express) ultimately led to a large decline in popularity, because PCIe speeds were able to outperform AGP and provide a singular slot type for all devices.</span></p>
<p><span lang="zh-TW" style="color: #99cc00;">AGP在很長一段時間內一直處於主導地位，但是PCIe（PCI Express）的引入最終導致了流行度的大幅下降，因為PCIe的速度能夠超過AGP並為所有設備提供單一的插槽類型。</span></p>
<p>Motherboards that provide AGP support have a single AGP slot. Several different versions of AGP have been implemented over the years</p>
<p>AGP 1.0 1x  Runs at 66 MHz with a data throughput rate of 266 MBps.<br/>AGP 1.0 2x  Runs at 66 MHz with a data throughput rate of 533 MBps.<br/>AGP 2.0 4x  Runs at 66 MHz with a data throughput rate of 1066 MBps.<br/>AGP 3.0 8x  Runs at 66 MHz with a data throughput rate of 2133 MBps.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW"><span style="color: #99cc00;">提供AGP支持的主機板有一個AGP插槽。這些年來，已經實現了AGP的幾種不同版本
</span>
<span style="color: #99cc00;">AGP 1.0 1x 以66 MHz運行，數據吞吐率為266 MBps。
AGP 1.0 2x 以66 MHz運行，數據吞吐率為533 MBps。
AGP 2.0 4x 以66 MHz運行，數據吞吐率為1066 MBps。
AGP 3.0 8x 以66 MHz運行，數據吞吐率為2133 MBps。</span></span></pre>
<h4 class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW"><span class="imagewrap"><span class="image"><img alt="Motherboard with AGP slot denoted by red rectangle." class="popimg" id="_i_2" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image3.png" title="Motherboard with AGP slot denoted by red rectangle."/><br/><span>PCI Express (PCIe) Expansion Slots</span></span></span></span></h4>
<p><span lang="zh-TW"><span class="imagewrap"><span class="image"><span>PCIe (PCI express) began replacing PCI, PCI-X, and AGP by 2005. Five slot sizes are available for PCIe  x1, x2, x4, x8, and x16. </span></span></span></span></p>
<p><span lang="zh-TW"><span class="imagewrap"><span class="image">PCIe（PCI Express）到2005年開始取代PCI，PCI-X和AGP。PCIe有五個插槽大小可供選擇 x1，x2，x4，x8和x16。</span></span></span></p>
<p><span lang="zh-TW"><span class="imagewrap"><span class="image"> PCIe x1 was designed to replace the old PCI cards for networking, modems, audio, input output, and other needs by connecting to the southbridge.</span></span></span></p>
<p class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW"><span style="color: #99cc00;">PCIe x1旨在通過連接到南橋來替代用於網絡，調製解調器，音頻，輸入 輸出和其他需求的舊PCI卡。</span><br/><span>It is worth noting that smaller PCIe cards can be placed in larger PCIe slots,<br/>and vice versa. For example, PCIe x2 can be inserted into PCIe x8,<br/>but PCIe x8 cannot be inserted into PCIe x2.<br/><span style="color: #99cc00;">值得注意的是，較小的PCIe卡可以放入較大的PCIe插槽中，反之亦然。例如，PCIe x2可以插入</span><br/><span><span style="color: #99cc00;">PCIe x8中，但PCIe x8不能插入PCIe x2中。</span><br/><span></span></span></span></span></p>
<p class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="en">There are different versions of PCIe slots. The maximum number of channels<br/>that can be assigned to a card inserted in a slot depends on the version of the card.<br/> <span><span style="color: #99cc00;">PCIe插槽有不同版本。可以為插入插槽中的卡分配的最大通道數取決於卡的版本。</span><br/></span></span></p>
<p class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="en">Basic PCIe provides one channel for transmission (x1) with a transmission<br/>rate of 250 MBps. It can also provide multiple transmission channels<br/>(x2, x4, x8, x16, x32).<br/><span style="color: #99cc00;">基本PCIe提供一個通道用於傳輸（x1），傳輸速率為250 MBps。它還可以提供多個傳輸通道</span><br/><span><span style="color: #99cc00;">（x2，x4，x8，x16，x32）。</span><br/></span></span></p>
<p id="N10710" lang="">Newer versions of PCIe can transfer data at an even higher rate per lane</p>
<ul lang="">
<li lang="">PCIe Version 1  250 MBps</li>
<li lang="">PCIe Version 2  500 MBps</li>
<li lang="">PCIe Version 3  1 Gbps</li>
<li lang="">PCIe Version 4  2 Gbps
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW" style="color: #99cc00;">較新版本的PCIe可以在每個通道上以更高的速率傳輸數據

PCIe版本1 250 MBps
PCIe版本2 500 MBps
PCIe版本3 1 Gbps
PCIe版本4 2 Gbps</span></pre>
</li>
</ul>
</blockquote>
<h3>Processors(處理器)</h3>
<p class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="en">Central processing unit is also called CPU or processor. The processor uses</span><span lang="en">two main architectures 32-bit and 64-bit. We denote 32-bit processors</span><span lang="en">(or applications designed<span> </span></span><span lang="en">for these processors) as x86. 64-bit processors<span> </span></span><span lang="en">and applications are represented as x64.</span></p>
<p><span lang="en" style="color: #99cc00;">中央處理單元也稱為CPU或處理器。處理器採用兩種主要架構32位和64位。我們將32位處理器（或為這些處理器設計的應用程序）表示為x86。 64位處理器和應用程序表示為x64。</span><span></span></p>
<p class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="en">Three things can distinguish CPU types1) socket type (which CPU will fit</span><span lang="en">which socket) 2) single-core or multi-core design 3) cache size. Although</span><span lang="en">Intel and AMD are fully compatible in running Windows operating systems,</span><span lang="en">if you are running UNIX Linux, you actually have to get the correct<span> </span></span><span lang="en">software for your CPU type.</span></p>
<p><span lang="en" style="color: #99cc00;">可以區分CPU類型的三件事1）套接字類型（哪個CPU將適合哪個套接字）  2）單核或多核設計  3）緩存的大小。儘管Intel和AMD在運行Windows操作系統方面是完全兼容的，但是如果您正在運行UNIX   Linux，則實際上必須為您的CPU類型獲得正確的軟件。</span><span lang="en"><br/></span><span lang="en"><span class="imagewrap"><span class="image"><img alt="A modern processor installed on a motherboard held between two fingers." class="popimg" id="_i_0" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image7.jpeg" title="A modern processor installed on a motherboard held between two fingers."/></span></span></span><span></span></p>
<p id="N106A2" lang="">Intel has been making processors for a long time and their contemporary processors all use the land grid array (LGA) socket style. LGA uses spring-loaded “lands” that connect with the bottom of the processor and a hinged clamp mechanism to hold the processor onto the motherboard. The heat sink is then snapped into the mounting holes at the four corners of the processor socket.</p>
<p id="N106A2" lang=""><span style="color: #99cc00;">英特爾長期以來一直在生產處理器，其現代處理器均使用陸地網格陣列（LGA）插槽樣式。 LGA使用彈簧加載的“平台”，該平台與處理器的底部連接，並通過鉸鍊式夾緊機構將處理器固定在主板上。然後將散熱器卡入處理器插槽四個角上的安裝孔。</span></p>
<p><span lang="en"><span class="imagewrap"><span class="image"><span class="imagewrap"><span class="image"><img alt="Spring-loaded lands and a hinged clamp mechanism mounted on the motherboard." class="popimg" id="_i_2" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image8.jpeg" title="Spring-loaded lands and a hinged clamp mechanism mounted on the motherboard."/></span></span></span></span></span><span></span></p>
<p id="N106B7" lang="">Common Intel land grid arrays</p>
<ul lang="">
<li lang="">LGA 775 – Pentium 4, Pentium D, Celeron, Core 2 Duo, Core 2 Quad, Core 2 Extreme</li>
<li lang="">LGA 1366 – Core i7 9xx, Xeon series</li>
<li lang="">LGA 1156 – Core i3, Core i5, Core i7 (not 9xx)</li>
<li lang="">LGA 1155 – Sandy Bridge Core i3, Core i5, Core i7 (second-generation)
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">常見的英特爾陸地網格陣列</span></pre>
</li>
<li lang="">
<h3>Video Displays and Video Cards(顯示器與顯示卡)</h3>
<p>Earlier, we mentioned the various types of expansion cards now we are going to focus on video graphics cards. Video cards come in many varieties, and are sold under numerous different naming conventions, like graphics cards, graphics accelerator cards, or graphics adapters. These cards are add-on cards that create the images you see on the display monitor. They can come in a variety of expansion card types to fit into the various expansion slots, such as PCI express (PCIe) that is currently dominant, advanced graphics port (AGP), or the older PCI slots. While many low-end desktops come with an integrated graphics chip in the CPU instead of using a dedicated card, this is not suitable for 3D games or CAD CAM (computer-aided manufacturing) workstations. Therefore, many users will opt to use an add-on graphics card, like the one displayed below, to improve their gaming performance.</p>
<span lang="zh-TW"></span></li>
<li lang=""><span style="color: #99cc00;"><span lang="zh-TW">在前面，我們提到了各種類型的擴充卡。現在我們將專注於視頻 圖形卡。視頻卡種類繁多，並以</span><span lang="zh-TW">多種不同的命名約定出售，例如圖形卡，圖形加速卡或圖形適配器。這些卡是附加卡，可創建您</span><span lang="zh-TW">在顯示屏 監視器上看到的圖像。它們可以有多種擴展卡類型以適合各種擴展插槽，例如當前占</span><span lang="zh-TW">主導地位的PCI Express（PCIe），高級圖形端口（AGP）或較舊的PCI插槽。儘管許多低端台</span><span lang="zh-TW">式機都在CPU中集成了圖形芯片，而不是使用專用卡，但這不適用於3D遊戲或CAD CAM（計算</span><span lang="zh-TW">機輔助製造）工作站。因此，許多用戶將選擇使用附加的圖形卡（如下面顯示的圖形卡）來改善</span><span lang="zh-TW">其遊戲性能。</span></span><span lang="zh-TW"><img alt="Red and silver video card with enclosed shroud and dedicated cooling fan." class="popimg" id="_i_0" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image12.png" title="Red and silver video card with enclosed shroud and dedicated cooling fan."/></span><span lang="zh-TW"></span></li>
<li lang="">
<h3>Video Output</h3>
<p><span lang="zh-TW"><span>Video output comes in various types of connectors based on the motherboard’s chipset or the graphics card’s chipset. The standard that has been used for the past few decades is the VGA (video graphics adapter), which is a DB-15 style connector. VGA relies on providing a good-quality analog output to a traditional computer monitor. The port for this connector is the blue one on the left in the image below.</span></span></p>
<span lang="zh-TW"></span></li>
<li lang="">
<p><span style="color: #99cc00;"><span lang="zh-TW">視頻輸出來自基於主板芯片組或圖形卡芯片組的各種類型的連接器。過去幾十年來一直使用的標</span><span lang="zh-TW">準是VGA（視頻圖形適配器），它是一種DB-15樣式的連接器。 VGA依靠向傳統的計算機顯示器</span><span lang="zh-TW">提供高質量的模擬輸出。該連接器的端口是下圖左側的藍色端口。</span></span></p>
<span lang="zh-TW"><img alt="Photograph depicting a blue VGA connector, a white DVI connector and a black HDMI type A connector." class="popimg" id="_i_2" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image13.png" title="Photograph depicting a blue VGA connector, a white DVI connector and a black HDMI type A connector."/></span></li>
<li lang=""><span lang="zh-TW"><span>The next connector port, shown in white in the middle of the photo above, is called DVI, or digital video interface. It comes in DVI-D (for digital output only), or DVI-I (for integrated output that can provide digital or analog output) varieties. A DVI-I connector can be used with an adapter to operate with a traditional VGA monitor in analog mode, as well.</span></span></li>
<li lang="">
<p><span style="color: #99cc00;"><span lang="zh-TW">下一個連接器端口（稱為DVI或數字視頻接口），在上方的照片中間以白色顯示。它具有DVI-D</span><span lang="zh-TW">（僅用於數字輸出）或DVI-I（用於可提供數字或模擬輸出的集成輸出）的品種。 DVI-I連接</span><span lang="zh-TW">器也可以與適配器一起使用，以在模擬模式下與傳統VGA顯示器一起使用。</span></span></p>
</li>
<li lang=""><span lang="zh-TW"><span>The third connector, shown on the right of the image, is an HDMI, or high-definition multimedia interface, connection. HDMI comes with three standard connector type type A (standard), C (mini), and D (micro). Although there is a designation for a type B, it has not been adopted by any manufacturers at this time. Version 2.0 supports 4K UHD and HDR-enabled devices. Micro HDMI has been largely adopted by the mobile telephone market and is included on almost all current models. The special thing about HDMI is that it isn’t limited to carrying just video, but instead carries both audio and video over a single HDMI cable. HDMI is fully digital and doesn’t support analog displays.</span></span></li>
<li lang="">
<p><span style="color: #99cc00;"><span lang="zh-TW">圖像右側顯示的第三個連接器是HDMI或高清多媒體接口連接。 HDMI帶有三種標準連接器類</span><span lang="zh-TW">型 A型（標準），C型（微型）和D型（微型）。儘管有B型的名稱，但目前尚未被任何製造商採用。</span><span lang="zh-TW">2.0版支持支持4K UHD和HDR的設備。微型HDMI已被移動電話市場廣泛採用，並且幾乎包含在所</span><span lang="zh-TW">有當前型號中。 HDMI的特殊之處在於，它不僅限於承載視頻，還可以通過一根HDMI電纜同時傳</span><span lang="zh-TW">輸音頻和視頻。 HDMI是全數字的，不支持模擬顯示。</span></span></p>
</li>
<li lang=""><span lang="zh-TW"><span>This makes it an ideal interface connector for laptops and mobile devices, similar to HDMI mini. It is also similar to HDMI in that it supports both video and audio with resolutions up to 3840x2160, which can support 4K UHD. DisplayPort can be found on IBM-clone (PC) machines and is gaining traction in the marketplace on mobile devices as well.</span></span></li>
<li lang=""><span style="color: #99cc00;"><span lang="zh-TW">這使其成為筆記本電腦和移動設備的理想接口連接器，類似於HDMI mini。它也與HDMI類似，</span><span lang="zh-TW">它同時支持視頻和音頻，分辨率高達3840x2160，可以支持4K UHD。 DisplayPort可以在</span><span lang="zh-TW">IBM克隆（PC）機器上找到，並且在移動設備市場上也越來越受歡迎。</span></span></li>
<li lang=""><span lang="zh-TW"><img alt="Photograph of a Mini DisplayPort on an Apple computer." class="popimg" id="_i_7" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image14.png" title="Photograph of a Mini DisplayPort on an Apple computer."/></span></li>
<li lang=""><span lang="zh-TW"><span>Component RGB (red green blue) is another high-definition connector type, but provides its output in analog format and only up to 720p of resolution. This was commonly used by VCR and DVD players, to connect to television sets, but can sometimes be found on older computers as a secondary output connector. Using RCA connectors, component video actually requires three connectors to pass the video signal to the TV, each one with a different colored label of red, green, and blue. Audio signals require separate patch cords.</span></span></li>
<li lang=""><span style="color: #99cc00;"><span lang="zh-TW">Component RGB（紅色，綠色，藍色）是另一種高清連接器類型，但以模擬格式提供其輸出，</span><span lang="zh-TW">並且分辨率最高僅為720p。 VCR和DVD播放器通常使用它來連接電視機，但有時可以在較舊的計</span><span lang="zh-TW">算機上找到它作為輔助輸出連接器。使用RCA連接器，分量視頻實際上需要三個連接器才能將視頻</span><span lang="zh-TW">信號傳遞到電視，每個連接器具有不同顏色的紅色，綠色和藍色標籤。音頻信號需要單獨的跳線。</span></span><span lang="zh-TW"><img alt="Photograph of a component/RGB with three ports arranged horizontally. Starting on the left, there is a green port labeled Y, a blue port labeled PB/CB, and a red port labeled PR/CR." class="popimg" id="_i_9" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image15.jpeg" title="Photograph of a component/RGB with three ports arranged horizontally. Starting on the left, there is a green port labeled Y, a blue port labeled PB/CB, and a red port labeled PR/CR."/></span></li>
<li lang="">
<h3>Install and Configure Expansion Cards(安裝和配置擴充卡)</h3>
<span lang="zh-TW"><span lang="zh-TW"><span>In the lab below, you should install an expansion video card. Be sure to use proper ESD precautions so as to avoid damaging fragile components.</span></span><span></span></span></li>
<li lang=""><span lang="zh-TW" style="color: #99cc00;">在下面的實驗室中，您應該安裝擴展視頻卡。確保使用正確的ESD預防措施，以避免損壞易碎的組件。</span><img alt="東訊SDX500卡片安裝@ 監視安防系統:: 隨意窩Xuite日誌" src="https://pic.pimg.tw/mofulls/1555761185-2961666508.png"/></li>
<li lang="">
<h3>Storage Devices Overview(存儲設備概述)</h3>
<p><span lang="zh-TW"><span>USB flash drives are commonplace today and have replaced floppy disks as the removable media of choice. They are small in physical size and large in memory capability, with the ability to store 64 GB or more of data on a single “stick.” They are popular and easy to use, since they don’t require a special card reader, because the USB device has one built-in. They are often formatted with the FAT-16, FAT-32, or exFAT file system and are ready to use straight out of the box. Simply plug the device into an available USB port, the operating system recognizes it, and you can begin copying, deleting, and modifying files.</span></span></p>
<p><span style="color: #99cc00;"><span lang="zh-TW">USB閃存驅動器在當今很普遍，並且已取代軟盤作為首選的可移動介質。它們的物理尺寸</span><span lang="zh-TW">很小，內存容量也很大，能夠在單個“棒”上存儲64 GB或更多的數據。它們很受歡迎且</span><span lang="zh-TW">易於使用，因為它們不需要特殊的讀卡器，因為USB設備內置了一個。它們通常使用</span><span lang="zh-TW">FAT-16，FAT-32或exFAT文件系統進行格式化，並且可以直接使用。只需將設備插入</span><span lang="zh-TW">用的USB端口，操作系統即可識別它，然後您就可以開始復制，刪除和修改文件了。</span></span></p>
<p><span lang="zh-TW"><img alt="Photograph depicting a USB flash drive. It is blue plastic and rectangular. There is a cap that is removed and set to the side, exposing the metal USB connector." class="popimg" id="_i_4" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image20.jpeg" title="Photograph depicting a USB flash drive. It is blue plastic and rectangular. There is a cap that is removed and set to the side, exposing the metal USB connector."/></span><span lang="zh-TW">Floppy disks dominated the removable storage arena until the late 1990s, and now they are nearly extinct in most organizations. While some removable USB thumb drives can store 64 GB or more of data, floppy disks usually only stored 1.44 MB of data. That means a single thumb drive can store the information from more than 60,000 floppy disks! Floppy disks used flexible magnetic media surrounded by a rigid plastic case. The most common floppy (shown in the bottom image) was the 3.5” floppy, which was named based on the diameter of the magnetic media inside the plastic case. It used to be commonplace to find a floppy disk drive on every computer, which was connected using a mini-molex or BERG power cable and a 34-pin internal IDE PATA cable. Contemporary machines typically do not have these drives, as they have fallen out of favor with the public. If you have a need for a floppy drive, one can be purchased for less than $20 that can connect to your computer using your USB port. Windows always reserves the A  and B  drives for the floppy disk drive (FDD), even if your system doesn’t have one.</span></p>
<p><span style="color: #99cc00;"><span lang="zh-TW">直到1990年代後期，軟盤一直在可移動存儲領域佔據著主導地位，現在在大多數組織中它</span><span lang="zh-TW">們幾乎已經滅絕。雖然某些可移動USB拇指驅動器可以存儲64 GB或更多的數據，但是軟盤</span><span lang="zh-TW">通常僅存儲1.44 MB的數據。這意味著一個拇指驅動器可以存儲來自60,000多個軟盤的</span><span lang="zh-TW">信息！軟盤使用柔性磁性介質，並由剛性塑料盒包圍。最常見的軟盤（如左圖所示）</span><span lang="zh-TW">是3.5英寸的軟盤，它是根據塑料盒內部磁性介質的直徑來命名的。過去通常在每台計算機</span><span lang="zh-TW">上都找到軟盤驅動器，該軟盤驅動器是使用minimolex或BERG電源電纜以及34針內部</span><span lang="zh-TW">IDE   PATA電纜連接的。現代機器通常不具有這些驅動器，因為它們已受到公眾的青睞。</span><span lang="zh-TW">如果您需要軟盤驅動器，則可以用不到20美元的價格購買一個軟盤驅動器，它可以使用</span><span lang="zh-TW">USB端口連接到計算機。 Windows始終將A 和B 驅動器保留為軟盤驅動器（FDD），</span><span lang="zh-TW">即使您的系統沒有該驅動器也是如此。</span></span></p>
<p><span lang="zh-TW"><img alt="A set of nine 3.5-inch floppy disks, three green and six yellow." class="popimg" id="_i_6" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image21.png" title="A set of nine 3.5-inch floppy disks, three green and six yellow."/></span></p>
<h3>Storage Devices Hard Disk Drives(儲存設備 硬碟驅動器)</h3>
<p>SSDs are intended to replace the traditional hard disk. They are fast and durable, and contain no moving parts. The SSD emulates a traditional hard drive and is often used in netbooks, Ultrabooks, and other lightweight systems, or machines that require fast, quiet performance. Most SSDs come in a 2.5-inch form factor, similar to a laptop hard disk, and use a 2.5-inch to 3.5-inch adapter when being placed in a desktop computer. The SSD can be built using multilevel cell (MLC) to save money, but these tend to be much slower than their more expensive and faster counterpart, the SLC (single level cell). Initially, these drives cost five to ten times as much as an equivalent-capacity traditional hard disk. Market demand and increased production have helped lower the pricing. As of the end of 2015, a 2.5-inch 250 GB SATAIII SSD can be purchased for less than $100, but the same amount of money would purchase a traditional 2 TB HDD. But, they are significantly faster and quieter, since they can access the information directly without having to wait for the hard disk to spin up and find the data on the disk.</p>
<p><span lang="zh-TW" style="color: #99cc00;">SSD旨在替代傳統硬盤。它們既快速又耐用，並且沒有活動部件。 SSD模仿傳統的硬盤驅動器，通常用於上網本，超極本和其他輕量級系統，或需要快速，安靜性能的機器中。大多數SSD的外形尺寸為2.5英寸，類似於筆記本電腦的硬盤，並且放在台式機中時使用2.5英寸至3.5英寸的適配器。可以使用多層單元（MLC）來構建SSD，以節省資金，但是這些SSD往往比價格更高，速度更快的同類產品SLC（單層單元）慢得多。最初，這些驅動器的成本是同等容量的傳統硬盤的五至十倍。市場需求和產量增加幫助降低了定價。截至2015年底，可以以不到100美元的價格購買2.5英寸250 GB SATAIII SSD，但以同樣的金額購買傳統的2 TB HDD。但是，它們可以更快，更安靜地運行，因為它們可以直接訪問信息，而不必等待硬盤啟動並在磁盤上查找數據。</span><span lang="zh-TW"><br/><img alt="Photograph depicting a solid state drive (SSD) with solid state chips on a circuit board." class="popimg" id="_i_6" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image26.png" title="Photograph depicting a solid state drive (SSD) with solid state chips on a circuit board."/><br/><span>Storage Devices Drive Interfaces(儲存設備 驅動器接口)</span><br/></span></p>
<p>SATA is the current connection method used for hard disks and optical drives. It is called serial because only a single device can be attached to each cable, and the data is transmitted in serial fashion (one bit at a time). These devices often do not have jumpers, but if they have one, it is used to configure the speed of data transfer or to enable a special feature like<span> </span>spread spectrum clocking<span> </span>. SATA is a peripheral device and is very fast, allowing for speeds of up to 6 Gbps for the newer version, or 3 Gbps for the older versions. The data cable is shaped like an L, with seven pins for data. The power cable is also L-shaped, but has 15 pins. Internal SATA ports can be converted to an eSATA (external SATA) port simply by using a header to connect the internal port.</p>
<p><span lang="zh-TW"><span style="color: #99cc00;">SATA是用於硬盤和光盤驅動器的當前連接方法。之所以稱為串行，是因為每條電纜只能連接一個設備，並且數據以串行方式（一次一位）傳輸。這些設備通常沒有跳線，但如果有跳線，則可用於配置數據傳輸速度或啟用特殊功能，例如擴頻時鐘。 SATA是外圍設備，速度非常快，新版本的速度高達6 Gbps，而舊版本的速度高達3 Gbps。數據電纜的形狀像L形，有七個用於數據傳輸的引腳。電源線也為L形，但有15針。只需使用接頭連接內部端口，即可將內部SATA端口轉換為eSATA（外部SATA）端口。</span><br/><img alt="Photograph depicting a SATA drive with the circuit board and connector exposed." class="popimg" id="_i_4" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image30.png" title="Photograph depicting a SATA drive with the circuit board and connector exposed."/><br/></span></p>
<p>SCSI, or small computer system interface, supports daisy-chaining of devices (internally or externally) with either seven devices (narrow SCSI) or 15 devices (wide SCSI). Each device in the chain is provided with a Device ID number that is configured using a selector switch, DIP (dual inline package) switch, or jumper block. SCSI is an older technology and has largely been replaced by SATA and eSATA. Narrow SCSI could only support speeds of up to 40 MBps, while wide SCSI could support up to 320 MBps.</p>
<p><span lang="zh-TW"><span style="color: #99cc00;">SCSI或小型計算機系統接口支持將設備（內部或外部）與7個設備（窄SCSI）或15個設備（寬SCSI）進行菊花鏈連接。鏈中的每個設備都提供了一個設備ID編號，該ID使用選擇器開關，</span><br/><span style="color: #99cc00;">DIP（雙列直插式封裝）開關或跳線塊進行配置。 SCSI是一種較舊的技術，在很大程度上</span><br/><span style="color: #99cc00;">已被SATA和eSATA取代。窄SCSI只能支持高達40 MBps的速度，而寬SCSI可以支持高達320 MBps的速度。</span><br/><img alt="Photograph depicting an HP Surestore DAT-drive with two blue SCSI ports on the back. There is also a power cord port and a power on/off toggle button." class="popimg" id="_i_6" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH07/webcontent/PCH07/image31.png" title="Photograph depicting an HP Surestore DAT-drive with two blue SCSI ports on the back. There is also a power cord port and a power on/off toggle button."/></span></p>
<h3>Storage Devices  Hot Swapping(儲存設備 熱交換)</h3>
<p style="text-align: left;"><span>When desktops were originally developed, they weren’t designed to allow for hot-swapping of devices. Hot-swapping is the act of adding or removing a device while the computer is still turned on. In the old days, the user would shut the system down, power the workstation off, then connect the device, and turn the machine back on, otherwise the computer wouldn’t recognize the new device. In the late 1990s, the Windows operating system began to allow hot-swapping of devices, which included USB and FireWire. This allowed the user to simply plug in a device, wait a few seconds, and then begin using it to store or retrieve data. Due to this hot-swapping, it is important that users use the “eject drive safely” feature in Windows before unplugging a device, otherwise </span><em class="bold" lang="">data loss will occur</em><span>. SATA eSATA also support hot-swapping, but only if AHCI (advanced host controller interface) is selected during configuration in the BIOS. If not, the drive will work as if it is an older PATA IDE device and will not support hot-swapping.</span></p>
<p><span lang="zh-TW" style="color: #99cc00;">最初開發台式機時，它們的設計不允許熱插拔設備。熱交換是在計算機仍打開時添加或刪除設備的操作。在過去，用戶會關閉系統，關閉工作站電源，然後連接設備，然後重新啟動計算機，否則計算機將無法識別新設備。在1990年代後期，Windows操作系統開始允許熱插拔設備，包括USB和FireWire。這使用戶可以簡單地插入設備，等待幾秒鐘，然後開始使用它來存儲或檢索數據。由於這種熱交換，在拔出設備電源之前，用戶必須在Windows中使用“安全彈出驅動器”功能，這一點很重要，否則會導致數據丟失。SATA eSATA也支持熱插拔，但前提是在BIOS中配置期間選擇了AHCI（高級主機控制器接口）。否則，驅動器將像舊的PATA IDE設備一樣工作，並且不支持熱插拔。</span></p>
<h3>Heat Sources(熱源)</h3>
<p><span lang="zh-TW"> Heat is generated through thermal radiation as a by-product of electromagnetic<br/>movement within the circuits of our computers. The heat is caused by the internal<br/>resistance that the electricity encounters as it flows throughout the computer,<br/>and this resistance creates enough heat that the computer often becomes very,<br/>very hot inside the case. Each component of the computer creates heat at a<br/>different rate, depending on the specific operations being performed. For example,<br/>the CPU generates the most heat, since it does the greatest number of computations<br/>and uses a large amount of electricity. Another common source of heat is the<br/>graphics processing unit (GPU), which does an enormous amount of processing<br/>when performing calculations required to support 3D graphics, such as those<br/>used in video gaming. Often, during gaming, the GPU will actually create more<br/>heat than the CPU.<br/></span></p>
<div><span lang="zh-TW"><span style="color: #99cc00;">通過熱輻射產生的熱量是我們計算機電路內電磁運動的副產品。熱量是由電流在整個計算機中流動時</span><br/><span style="color: #99cc00;">遇到的內部電阻引起的，並且該電阻產生的熱量足以使計算機在機殼內部變得非常非常熱。計算機的</span><br/><span style="color: #99cc00;">每個組件都會以不同的速度產生熱量，具體取決於所執行的特定操作。例如，CPU產生的熱量最多，</span><br/><span style="color: #99cc00;">因為它進行了大量的計算並消耗大量電能。另一個常見的熱量來源是圖形處理單元（GPU），當執行</span><br/><span style="color: #99cc00;">支持3D圖形的計算時（例如視頻遊戲中使用的那些計算），它會進行大量處理。通常，在遊戲過程中，</span><br/><span style="color: #99cc00;">GPU實際上會比CPU產生更多的熱量。</span><br/><br/><span>Often there is no indication to the end user that an overheating condition is<br/>occurring, but even this can have severe consequences. Hard disk drives, CPUs,<br/>and GPUs are all sensitive to temperature changes. Hard drives in particular can<br/>become irreparably damaged by temperature changes due to the expansion and<br/>contraction of device components. This can cause read write errors, or even a<br/>complete failure of the disk drive.<br/></span></span></div>
<p class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW" style="color: #99cc00;">通常，最終用戶沒有跡象表明發生了過熱情況，但即使這樣也會造成嚴重後果。硬盤驅動器，<br/>CPU和GPU都對溫度變化敏感。由於設備組件的膨脹和收縮，特別是硬盤驅動器會因溫度變化而造成不可挽回的損害。這可能導致讀 寫錯誤，甚至導致磁盤驅動器完全故障。</span></p>
<h3>heat reduction</h3>
<p class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW">There are many ways to reduce the amount of heat generated in a computer,<br/>but the most notable way is the use of a heat sink, like the one pictured<br/>below in green. A heat sink works to draw heat away from the sensitive<br/>components, such as the CPU, GPU, northbridge, and southbridge, through<br/>conduction. It then uses the fins to dissipate heat across a wider surface<br/>area. A fan usually moves air over the surface to remove the heat from the<br/>heat sink and push it out the computer’s exhaust vents on the back of the<br/>system. Heat sinks are created out of aluminum alloys or copper, which are<br/>soft metals with high heat conductivity.<br/></span></p>
<p class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW"><span style="color: #99cc00;">有許多方法可以減少計算機中產生的熱量，但是最值得注意的方法是使用散熱器，如下面的綠色</span><br/><span style="color: #99cc00;">圖片所示。散熱器通過傳導將熱量從敏感組件（例如CPU，GPU，北橋和南橋）吸走。然後，它使</span><br/><span style="color: #99cc00;">用散熱片在更寬的表面積上散熱。風扇通常將空氣移動到表面上方，以從散熱器中散熱，然後將其</span><br/><span style="color: #99cc00;">從系統背面的計算機排氣孔中推出。散熱器由鋁合金或銅製成，而鋁合金或銅是具有高導熱性的軟金屬。</span><br/><img alt="Photograph of a heat sink. It is a square metal device with a round device with fins sitting on top. The round device is labeled “CPU Cooler.”" class="popimg" id="_i_0" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH08/webcontent/PCH08/image1.png" title="Photograph of a heat sink. It is a square metal device with a round device with fins sitting on top. The round device is labeled “CPU Cooler.”"/></span></p>
</li>
<li lang="">
<h3>BIOS Settings(bios設置)</h3>
<p style="text-align: left;"><span lang="zh-TW">Most modern motherboards and BIOS support temperature monitoring and control<br/>for the motherboard and its components. The name for this varies depending on<br/>manufacturer, but often it is called PC health or temperature monitoring.<br/>For motherboards that support overclocking, you can configure the settings<br/>in the BIOS to increase or decrease your processing capability, and thereby<br/>prevent additional heat from being generated. The CPU has a sensor that monitors<br/>its temperature, and the BIOS can increase or decrease the fan speed to control<br/>the temperature of the CPU. Remember, though, by reducing the power consumption<br/>(and therefore heat), you are also simultaneously reducing the performance of<br/>the CPU.</span></p>
<p style="text-align: left;"><span lang="zh-TW"><span style="color: #99cc00;">大多數現代主板和BIOS支持對主板及其組件進行溫度監控。其名稱因製造商而異，但通常稱為PC運行狀況或溫度監控。對於支持超頻的主板，您可以在BIOS中配置設置以增加或減少處理能力，從而防止產生更多的熱量。 CPU具有監視其溫度的傳感器，BIOS可以增加或減小風扇速度以控制CPU的溫度。但是請記住，通過減少功耗（並因此減少熱量），您同時也在降低CPU的性能。</span><img alt="Photograph of a BIOS screen that provides a graph of system temperature and actual temperature measurements within the CPU and memory, along with ambient temperature. It also charts fan speeds (via tachometer readings) in the CPU, memory, chassis, chipset, and PCI." class="popimg" id="_i_0" onclick="loadImageFromPage(this);" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH08/webcontent/PCH08/image2.png" title="Photograph of a BIOS screen that provides a graph of system temperature and actual temperature measurements within the CPU and memory, along with ambient temperature. It also charts fan speeds (via tachometer readings) in the CPU, memory, chassis, chipset, and PCI."/></span></p>
<h2>HW2</h2>
</li>
<li lang=""><a href="https://www.kaggle.com/yuyang0402/cp2020-hw2">https://www.kaggle.com/yuyang0402/cp2020-hw2</a></li>
<li lang="">
<h3>作業2-1</h3>
<span>參考40923211</span>

<span>方法一 :</span><span></span></li>
<li lang="">
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import urllib.request
#導入urllib.request
target_url = "https://nfulist.herokuapp.com/?semester=1091&amp;courseno=0776"
#設target_url = "網址"
cp1b = []
#設cp1b=數列
for line in urllib.request.urlopen(target_url):
#重複打開target_url的迴圈定義line
    cp1b.append(int(line.decode('utf-8').rstrip()))
    #把line重新編碼加進cp1b(數列)   註:rstrip()刪除字尾符號
print(cp1b)
</pre>
<span><img alt="" height="264" src="https://40923211.github.io/cp2020/images/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202020-12-08%20153151.png" width="456"/></span><span></span></li>
<li lang="">
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from random import shuffle #導入隨機洗牌
list  = [40523138,40523148,40723217,40728238,40823148,40823152,40923201,40923202,40923203,40923204,40923205,
40923206,40923207,40923208,40923209,40923210,40923211,40923212,40923213,40923214,40923216,40923217,40923218,
40923219,40923220,40923221,40923223,40923224,40923225,40923226,40923227,40923228,40923229,40923230,40923231,
40923232,40923233,40923234,40923235,40923236,40923237,40923238,40923239,40923240,40923241,40923242,40923243,
40923244,40923245,40923246,40923247,40923248,40923249,40923250,40923251,40923252,40923253] 
#列表[]
shuffle(list) #shuffle=洗牌
n=5
m = int(len(list)/n) 
list2 = [] 
for i in range(0, len(list), m): #range()是一个函数， for i in range () 就是给i赋值： 
    list2.append(list[i:i+m]) 
print(list2) </pre>
<span><br/></span></li>
<li lang="">
<h3>變數 Variables</h3>
</li>
<li lang=""><span>Variables, expressions, and statements,Values and types</span>
<p><br/>變量，表達式和語句，值和類型</p>
<p>A<span> </span><em>value</em><span> </span>is one of the basic things a program works with, like a letter or a number. The values we have seen so far are<span> </span><code>1</code>,<span> </span><code>2</code>, and "Hello, World!"</p>
<p>值是程序使用的基本內容之一，例如字母或數字。到目前為止，我們看到的值為1、2和“ Hello，World！”。</p>
<p>These values belong to different<span> </span><em>types</em>:<span> </span><code>2</code><span> </span>is an integer, and "Hello, World!" is a<span> </span><em>string</em>, so called because it contains a "string" of letters. You (and the interpreter) can identify strings because they are enclosed in quotation marks.</p>
<p>這些值屬於不同的類型：2是整數，“ Hello，World！”是字符串，之所以稱為字符串是因為它包含字母的“字符串”。您（和解釋器）可以識別字符串，因為它們用引號引起來。</p>
<p>The<span> </span><code>print</code><span> </span>statement also works for integers. We use the<span> </span><code>python</code><span> </span>command to start the interpreter.</p>
<p>print語句也適用於整數。我們使用python命令啟動解釋器。</p>
<div>
<div class="syntaxhighlighter py" id="highlighter_958918">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py plain">python</code></div>
<div class="line number2 index1 alt1"><code class="py plain">&gt;&gt;&gt; </code><code class="py functions">print</code><code class="py plain">(</code><code class="py value">4</code><code class="py plain">)</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p><span>If you are not sure what type a value has, the interpreter can tell you.</span></p>
<p><span>如果您不確定值的類型，解釋器可以告訴您。</span></p>
<p><span>Not surprisingly, strings belong to the type <code>str</code><span><span> </span>and integers belong to the type<span> </span></span><code>int</code><span>. Less obviously, numbers with a decimal point belong to a type called<span> </span></span><code>float</code><span>, because these numbers are represented in a format called<span> </span></span><em>floating point</em></span></p>
<p><span><em>毫不奇怪，字符串屬於str類型，而整數屬於int類型。不太明顯的是，帶小數點的數字屬於稱為浮點的類型，因為這些數字以稱為浮點的格式表示</em></span></p>
<p>What about values like "17" and "3.2"? They look like numbers, but they are in quotation marks like strings.</p>
<p>那麼“ 17”和“ 3.2”之類的值呢？它們看起來像數字，但用引號引起來，例如字符串。</p>
<div>
<div class="syntaxhighlighter py" id="highlighter_211233">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py plain">&gt;&gt;&gt; </code><code class="py functions">type</code><code class="py plain">(</code><code class="py string">'17'</code><code class="py plain">)</code></div>
<div class="line number2 index1 alt1"><code class="py plain">&gt;&gt;&gt; </code><code class="py functions">type</code><code class="py plain">(</code><code class="py string">'3.2'</code><code class="py plain">)</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>They're strings.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">他們是字符串。</span></pre>
<p>When you type a large integer, you might be tempted to use commas between groups of three digits, as in<span> </span><code>1,000,000</code>. This is not a legal integer in Python, but it is legal:</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW">當您輸入一個大整數時，您可能會想在三位數的組之間使用逗號，例如1,000,000。在Python中這不是合法的整數，但它是合法的：<br/></span></pre>
<div>
<div class="syntaxhighlighter py" id="highlighter_785352">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py plain">&gt;&gt;&gt; </code><code class="py functions">print</code><code class="py plain">(</code><code class="py value">1</code><code class="py plain">,</code><code class="py value">000</code><code class="py plain">,</code><code class="py value">000</code><code class="py plain">)</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW"><span>Well, that's not what we expected at all! Python interprets </span><code>1,000,000</code><span><span> </span>as a comma-separated sequence of integers, which it prints with spaces between.</span><br/>好吧，這根本不是我們所期望的！ Python將1,000,000解釋為以逗號分隔的整數序列，並在其之間打印出空格。<br/></span></pre>
<p>This is the first example we have seen of a semantic error: the code runs without producing an error message, but it doesn't do the "right" thing.</p>
<p>這是我們看到的第一個語義錯誤示例：代碼運行時未產生錯誤消息，但沒有做“正確的”事情。</p>
<p>Variables 變數</p>
<p><span>One of the most powerful features of a programming language is the ability to manipulate </span><em>variables</em><span>. A variable is a name that refers to a value.</span></p>
<p><span>編程語言最強大的功能之一就是能夠操縱變量。變量是引用值的名稱。</span></p>
<p><span>An <em>assignment statement</em><span><span> </span>creates new variables and gives them values:</span></span></p>
<p><span><span>賦值語句創建新變量並為其提供值：</span></span></p>
<div>
<div class="syntaxhighlighter py" id="highlighter_827705">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py plain">&gt;&gt;&gt; message </code><code class="py keyword">=</code> <code class="py string">'And now for something completely different'</code></div>
<div class="line number2 index1 alt1"><code class="py plain">&gt;&gt;&gt; n </code><code class="py keyword">=</code> <code class="py value">17</code></div>
<div class="line number3 index2 alt2"><code class="py plain">&gt;&gt;&gt; pi </code><code class="py keyword">=</code> <code class="py value">3.1415926535897931</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW"><span>This example makes three assignments. The first assigns a string to a new variable named </span><code>message</code><span>; the second assigns the integer<span> </span></span><code>17</code><span><span> </span>to<span> </span></span><code>n</code><span>; the third assigns the (approximate) value of<span> </span></span><span class="math"><em>π</em></span><span><span> </span>to<span> </span></span><code>pi</code><span>.</span><br/>本示例進行了三個分配。第一個將字符串分配給一個名為message的新變量；第二個將整數17分配給n；第三個將π的（近似）值分配給pi。<br/><span>To display the value of a variable, you can use a print statement:</span><br/>要顯示變量的值，可以使用打印語句：<br/></span></pre>
<div>
<div class="syntaxhighlighter py" id="highlighter_797861">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
<div class="line number4 index3 alt1">4</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py plain">&gt;&gt;&gt; </code><code class="py functions">print</code><code class="py plain">(n)</code></div>
<div class="line number2 index1 alt1"><code class="py value">17</code></div>
<div class="line number3 index2 alt2"><code class="py plain">&gt;&gt;&gt; </code><code class="py functions">print</code><code class="py plain">(pi)</code></div>
<div class="line number4 index3 alt1"><code class="py value">3.141592653589793</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>The type of a variable is the type of the value it refers to.</p>
<p>變量的類型是它所引用的值的類型。</p>
<div>
<div class="syntaxhighlighter html" id="highlighter_161499">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
<div class="line number4 index3 alt1">4</div>
<div class="line number5 index4 alt2">5</div>
<div class="line number6 index5 alt1">6</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="html plain">&gt;&gt;&gt; type(message)</code></div>
<div class="line number2 index1 alt1"><code class="html plain">&lt;</code><code class="html keyword">class</code> <code class="html plain">'str'&gt;</code></div>
<div class="line number3 index2 alt2"><code class="html plain">&gt;&gt;&gt; type(n)</code></div>
<div class="line number4 index3 alt1"><code class="html plain">&lt;</code><code class="html keyword">class</code> <code class="html plain">'int'&gt;</code></div>
<div class="line number5 index4 alt2"><code class="html plain">&gt;&gt;&gt; type(pi)</code></div>
<div class="line number6 index5 alt1"><code class="html plain">&lt;</code><code class="html keyword">class</code> <code class="html plain">'float'&gt;</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</li>
<li lang="">
<h3>HTML Tutorial HTML教程</h3>
<p><strong>HTML Introduction HTML簡介</strong></p>
<p><span>HTML is the standard markup language for creating Web pages.</span></p>
<p>HTML是用於創建網頁的標準標記語言。</p>
<p><strong>What is HTML? 什麼是HTML？</strong></p>
<ul>
<li>HTML stands for Hyper Text Markup Language</li>
<li>HTML代表超文本標記語言</li>
<li>HTML is the standard markup language for creating Web pages</li>
<li>HTML是用於創建網頁的標準標記語言</li>
<li>HTML describes the structure of a Web page</li>
<li>HTML描述了網頁的結構</li>
<li>HTML consists of a series of elements</li>
<li>HTML由一系列元素組成</li>
<li>HTML elements tell the browser how to display the content</li>
<li>HTML元素告訴瀏覽器如何顯示內容</li>
<li>HTML elements label pieces of content such as "this is a heading", "this is a paragraph", "this is a link", etc.</li>
<li>HTML元素標記內容的內容，例如“這是標題”，“這是段落”，“這是鏈接”等。</li>
</ul>
<p><strong>A Simple HTML Document 一個簡單的HTML文檔</strong></p>
<p><strong>Example 範例<br/></strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Page Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;h1&gt;My First Heading&lt;/h1&gt;
&lt;p&gt;My first paragraph.&lt;/p&gt;
 
&lt;/body&gt;
&lt;/html&gt;</pre>
<p><strong>Example Explained 示例說明</strong></p>
<ul>
<li>The<span> </span><code class="w3-codespan">&lt;!DOCTYPE html&gt;</code><span> </span>declaration defines that this document is an HTML5 document</li>
<li>&lt;！DOCTYPE html&gt;聲明定義此文檔為HTML5文檔</li>
<li>The<span> </span><code class="w3-codespan">&lt;html&gt;</code><span> </span>element is the root element of an HTML page</li>
<li>&lt;html&gt;元素是HTML頁面的根元素</li>
<li>The<span> </span><code class="w3-codespan">&lt;head&gt;</code><span> </span>element contains meta information about the HTML page</li>
<li>&lt;head&gt;元素包含有關HTML頁面的元信息</li>
<li>The<span> </span><code class="w3-codespan">&lt;title&gt;</code><span> </span>element specifies a title for the HTML page (which is shown in the browser's title bar or in the page's tab)</li>
<li>&lt;title&gt;元素指定HTML頁面的標題（顯示在瀏覽器的標題欄中或頁面的選項卡中）</li>
<li>The<span> </span><code class="w3-codespan">&lt;body&gt;</code><span> </span>element defines the document's body, and is a container for all the visible contents, such as headings, paragraphs, images, hyperlinks, tables, lists, etc.</li>
<li>&lt;body&gt;元素定義文檔的正文，並且是所有可見內容的容器，例如標題，段落，圖像，超鏈接，表格，列表等。</li>
<li>The<span> </span><code class="w3-codespan">&lt;h1&gt;</code><span> </span>element defines a large heading</li>
<li>&lt;h1&gt;元素定義一個大標題</li>
<li>The<span> </span><code class="w3-codespan">&lt;p&gt;</code><span> </span>element defines a paragraph</li>
<li>&lt;p&gt;元素定義一個段落</li>
</ul>
<p><strong>What is an HTML Element? 什麼是HTML元素？</strong></p>
<p>An HTML element is defined by a start tag, some content, and an end tag:</p>
<p>HTML元素由開始標籤，一些內容和結束標籤定義：</p>
<div><span>&lt;tagname&gt;</span>Content goes here...<span>&lt;/tagname&gt;</span></div>
<div>
<p>The HTML<span> </span><strong>element</strong><span> </span>is everything from the start tag to the end tag:</p>
<p>HTML元素包括從開始標記到結束標記的所有內容：</p>
<div><span>&lt;h1&gt;</span>My First Heading<span>&lt;/h1&gt;</span></div>
<div>
<div><span>&lt;p&gt;</span>My first paragraph.<span>&lt;/p&gt;</span></div>
<div><span><img alt="" height="150" src="https://40923221.github.io/cp2020/images/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202021-01-03%20200637.png" width="1270"/></span></div>
<div>
<div class="w3-panel w3-note">
<p><strong>Note:</strong><span> </span>Some HTML elements have no content (like the &lt;br&gt; element). These elements are called empty elements. Empty elements do not have an end tag!</p>
<p>注意：某些HTML元素沒有內容（例如&lt;br&gt;元素）。這些元素稱為空元素。空元素沒有結束標籤！</p>
<p><strong>Web Browsers 網頁瀏覽器</strong></p>
</div>
</div>
</div>
</div>
<div>
<p>The purpose of a web browser (Chrome, Edge, Firefox, Safari) is to read HTML documents and display them correctly.</p>
<p>網絡瀏覽器（Chrome，Edge，Firefox，Safari）的目的是讀取HTML文檔並正確顯示它們。</p>
<p>A browser does not display the HTML tags, but uses them to determine how to display the document:</p>
<p>瀏覽器不顯示HTML標記，而是使用它們來確定如何顯示文檔：</p>
<img alt="View in Browser" class="w3-image" src="https://www.w3schools.com/html/img_chrome.png"/></div>
<div><strong>HTML Page Structure HTML頁面結構</strong></div>
<div>
<p>Below is a visualization of an HTML page structure:</p>
<p>下面是HTML頁面結構的可視化：</p>
<p><img alt="" height="517" src="https://40923221.github.io/cp2020/images/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202021-01-03%20200945.png" width="1253"/></p>
<div class="w3-panel w3-note">
<p><strong>Note:</strong><span> </span>The content inside the &lt;body&gt; section (the white area above) will be displayed in a browser. The content inside the &lt;title&gt; element will be shown in the browser's title bar or in the page's tab.</p>
<p>注意：&lt;body&gt;部分（上面的白色區域）內的內容將在瀏覽器中顯示。 &lt;title&gt;元素內的內容將顯示在瀏覽器的標題欄中或頁面的選項卡中。</p>
<p><strong>HTML History HTML歷史</strong></p>
<p>Since the early days of the World Wide Web, there have been many versions of HTML:</p>
<p>自萬維網問世以來，已經有許多版本的HTML：</p>
<p><img alt="" height="540" src="https://40923221.github.io/cp2020/images/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202021-01-03%20201133.png" width="568"/></p>
<div class="w3-panel w3-note">
<p>This tutorial follows the latest HTML5 standard.</p>
<p>本教程遵循最新的HTML5標準。</p>
</div>
</div>
</div>
<h2>HW3</h2>
<h3><span>Check Tic Tac Toe</span></h3>
<p><em>This exercise is Part 2 of 4 of the Tic Tac Toe exercise series. The other exercises are:<span> </span><a href="https://www.practicepython.org/exercise/2014/12/27/24-draw-a-game-board.html">Part 1</a>,<span> </span><a href="https://www.practicepython.org/exercise/2015/11/26/27-tic-tac-toe-draw.html">Part 3</a>, and<span> </span><a href="https://www.practicepython.org/exercise/2016/08/03/29-tic-tac-toe-game.html">Part 4</a>.</em></p>
<p>As you may have guessed, we are trying to build up to a full tic-tac-toe board. However, this is significantly more than half an hour of coding, so we’re doing it in pieces.</p>
<span>您可能已經猜到了，我們正在努力建立完整的井字遊戲板。但是，這遠遠超過了半個小時的編碼，因此我們要分批進行。</span>
<p></p>
<p></p>
<p>Today, we will simply focus on checking whether someone has WON a game of Tic Tac Toe, not worrying about how the moves were made.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">我們只關注檢查某人是否贏得了井字遊戲，而不用擔心這些動作是如何進行的。</span></pre>
<p></p>
<p>If a game of Tic Tac Toe is represented as a list of lists, like so:</p>
<figure class="highlight">
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">game = [[1, 2, 0],
	[2, 1, 0],
	[2, 1, 1]]</pre>
<pre><code class="language-python" data-lang="python"><span class="p"><br/><br/></span></code></pre>
<p style="text-align: left;">where a<span> </span><code class="highlighter-rouge">0</code><span> </span>means an empty square, a<span> </span><code class="highlighter-rouge">1</code><span> </span>means that player 1 put their token in that space, and a<span> </span><code class="highlighter-rouge">2</code><span> </span>means that player 2 put their token in that space.</p>
<p style="text-align: left;">Your task this week: given a 3 by 3 list of lists that represents a Tic Tac Toe game board, tell me whether anyone has won, and tell me which player won, if any. A Tic Tac Toe win is 3 in a row - either in a row, a column, or a diagonal. Don’t worry about the case where TWO people have won - assume that in every board there will only be one winner.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">給定一個代表Tic Tac Toe遊戲板的3 x 3列表，請告訴我是否有人贏了，並告訴我哪<br/>個玩家贏了（如果有）。井字遊戲的勝利是連續3個-連續，一列或對角線。不必擔心會<br/>有兩個人獲勝的情況-假設在每個董事會中只有一個獲勝者。</span></pre>
<p style="text-align: left;">Here are some more examples to work with:</p>
<figure class="highlight" style="text-align: left;">
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">winner_is_2 = [[2, 2, 0],
	[2, 1, 0],
	[2, 1, 1]]

winner_is_1 = [[1, 2, 0],
	[2, 1, 0],
	[2, 1, 1]]

winner_is_also_1 = [[0, 1, 0],
	[2, 1, 0],
	[2, 1, 1]]

no_winner = [[1, 2, 0],
	[2, 1, 0],
	[2, 1, 2]]

also_no_winner = [[1, 2, 0],
	[2, 1, 0],
	[2, 1, 0]]</pre>
<pre><br/><br/></pre>
</figure>
<h4 id="topics">Topics</h4>
<p>This exercise is challenging, but doable with only lists (of lists)! Lists of lists are nearly the same as lists, just a bit trickier. Remember that to get the first element in a list called<span> </span><code class="highlighter-rouge">my_list = [5, 10, 15]</code>, you index it with a variable like so:</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">僅可使用列表中的列表！列表的列表與列表幾乎相同，只是比較棘手。請記住，要獲取<br/>名為my_list = [5，10，15]的列表中的第一個元素，請使用如下所示的變量對其進<br/>行索引：</span></pre>
<figure class="highlight">
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; print(my_list[0])
	5
	&gt;&gt;&gt; print(my_list[-1])
	15
	&gt;&gt;&gt; print(len(my_list))
	3</pre>
</figure>
<p>When working with lists of lists, it is the same! Say you have a list<span> </span><code class="highlighter-rouge">matrix = [[1, 2], [3, 4]]</code>. Then, take a look at this:</p>
<figure class="highlight">
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; print(matrix[0])
	[1, 2]
	&gt;&gt;&gt; print(matrix[-1])
	[3, 4]
	&gt;&gt;&gt; first_row = matrix[0]
	&gt;&gt;&gt; print(first_row[0])
	1
	&gt;&gt;&gt; print(matrix[0][0])
	1
	&gt;&gt;&gt; print(matrix[1][1])
	4</pre>
</figure>
<p>The cool part is that you can use double-indexing to read the elements from our list of lists<span> </span><code class="highlighter-rouge">matrix</code>! By indexing<span> </span><code class="highlighter-rouge">matrix[0][1]</code><span> </span>we are saying give me the 1st element of the 0th element of<span> </span><code class="highlighter-rouge">matrix</code>, which in this case is<span> </span><code class="highlighter-rouge">2</code>.<span lang="zh-TW">最酷的部分是您可以使用雙索引從列表列表矩陣中讀取元素！通過索引矩陣[0] [1]，我們要給我矩陣第0個元素的第一個元素，在這種情況下為2。</span></p>
<h3><span lang="zh-TW"><span>Max Of Three</span></span></h3>
<p>Implement a function that takes as input three variables, and returns the largest of the three. Do this without using the Python<span> </span><code class="highlighter-rouge">max()</code><span> </span>function!</p>
<p>The goal of this exercise is to think about some internals that Python normally takes care of for us. All you need is some variables and<span> </span><code class="highlighter-rouge">if</code><span> </span>statements!</p>
<h4><span>Max Of Three Solutions</span></h4>
<h4 id="sample-solutions">Sample solutions</h4>
<p>There are many ways to answer this question, ranging from simple to complex. Here are a few reader-submitted answers!</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">有許多方法可以回答此問題，從簡單到復雜。這是讀者提交的一些答案！</span></pre>
<p>This first example solution uses a series of<span> </span><code class="highlighter-rouge">if</code><span> </span>statements and comparisons to find the largest of 3 elements.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def max_of_three(a,b,c):
     max_3=0
     if a&gt;b:
         #max_3=a
         if a&gt;c:
             max_3=c
         else:
             max_3=a
     else:
          if b&gt;c:
             max_3=b
          else:
             max_3=c
     return max_3</pre>
<p><span>Another solution is a little bit less verbose, taking 3 numbers as an input, making them into a list, sorting them, and then reading off the largest element.</span></p>
<p><span lang="zh-TW">另一個解決方案是稍微冗長一些，將3個數字作為輸入，將它們放入列表，對它們進行排序，然後讀取最大的元素。</span></p>
<p><span lang="zh-TW"><span>This last solution uses a more compact series of </span><code class="highlighter-rouge">if</code><span><span> </span>statement comparisons to cover all cases of 3 elements.</span></span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#!/usr/bin/env python
import sys

if len(sys.argv) &lt; 4:
    print 'Usage &lt;value1&gt; &lt;value2&gt; &lt;value3&gt;'
    sys.exit ( 1 )
    
arg1 = sys.argv[1]
arg2 = sys.argv[2]
arg3 = sys.argv[3]
def maxfunction(a,b,c):
	if (a &gt; b) and (a &gt; c):
	    print 'Max value is :',a
        elif (b &gt; a) and (b &gt; c):
            print 'Max value is :',b
        elif (c &gt; a) and (c &gt; b):
            print 'Max value is :',c
            
maxfunction(arg1,arg2,arg3)</pre>
<h3><span>Tic Tac Toe Game</span></h3>
<h4 id="sample-solution">Sample solution</h4>
<p>This exercise is unique because it relies on the output of the other exercises that need to be put together to make the final solution. The goal is to get practice with functions and how they work together in larger programs.</p>
<p><span>該練習是獨特的，因為它依賴於需要匯總以得出最終解決方案的其他練習的輸出。目的是練習功能以及它們如何在較大的程序中協同工作。</span></p>
<p>The 3 exercises above suggest breaking your Tic Tac Toe game into (at least) 4 functions:</p>
<ol>
<li>A function for drawing the game board (and the location of pieces)</li>
<li>A function for checking whether there is a winner in the game</li>
<li>A function for adding user input into the game state</li>
<li>A main function that calls the others and plays the game</li>
</ol>
<p>The way to solve this problem is to look back at all 3 solutions to the previous exercises, copy them into one file, and modify what you had before. This is a different way of coding than coding an entire program from scratch, and can often save a lot of time.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">解決此問題的方法是回顧一下先前練習的所有3個解決方案，將它們複製到一個文件中，<br/>然後修改之前的內容。與從頭開始編寫整個程序相比，這是一種不同的編碼方式，通常<br/>可以節省大量時間。</span></pre>
<p>For my solution, I decided to copy all the functions from the older exercises into one file, and work from the main game logic from<span> </span><a href="https://www.practicepython.org/exercise/2015/11/26/27-tic-tac-toe-draw.html">Part 3</a>. Part 3 almost made you write the entire game - the main loop asking users for positions and input is already there, so starting from that point and modifying will let you finish this exercise in 30 minutes!</p>
<p>Here is what my code looks like after copying in my solutions to<span> </span><a href="https://www.practicepython.org/exercise/2014/12/27/24-draw-a-game-board.html">Part 1</a>,<span> </span><a href="https://www.practicepython.org/exercise/2015/11/16/26-check-tic-tac-toe.html">Part 2</a>, and<span> </span><a href="https://www.practicepython.org/exercise/2015/11/26/27-tic-tac-toe-draw.html">Part 3</a><span> </span>of this exercise:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def draw_line(width, edge, filling):
	print(filling.join([edge] * (width + 1)))

def draw_board(width, height):
	draw_line(width, " ", "__")
	for i in range(height):
		draw_line(width, "|", "__")
	print("\n")

def display_winner(player):
	if player == 0:
		print("Tie")
	else:
		print("Player " + str(player) + " wins!")

def check_row_winner(row):
	"""
	Return the player number that wins for that row.
	If there is no winner, return 0.
	"""
	if row[0] == row[1] and row[1] == row[2]:
		return row[0]
	return 0

def get_col(game, col_number):
	return [game[x][col_number] for x in range(3)]

def get_row(game, row_number):
	return game[row_number]

def check_winner(game):
	game_slices = []
	for index in range(3):
		game_slices.append(get_row(game, index))
		game_slices.append(get_col(game, index))

	# check diagonals
	down_diagonal = [game[x][x] for x in range(3)]
	up_diagonal = [game[0][2], game[1][1], game[2][0]]
	game_slices.append(down_diagonal)
	game_slices.append(up_diagonal)

	for game_slice in game_slices:
		winner = check_row_winner(game_slice)
		if winner != 0:
			display_winner(winner)
			return winner

	display_winner(winner)
	return winner

def start_game():
	return [[0, 0, 0] for x in range(3)]

def display_game(game):
	d = {2: "O", 1: "X", 0: " "}
	game_string = []
	for row_num in range(3):
		new_row = []
		for col_num in range(3):
			new_row.append(d[game[row_num][col_num]])
		game_string.append(new_row)
	print(game_string)


def add_piece(game, player, row, column):
	"""
	game: game state
	player: player number
	row: 0-index row
	column: 0-index column
	"""
	game[row][column] = player
	return game

def convert_input_to_coordinate(user_input):
	return user_input - 1

def switch_player(player):
	if player == 1:
		return 2
	else:
		return 1


if __name__ == '__main__':
	game = start_game()
	display_game(game)
	player = 1

	# go on forever
	while True:
		print("Currently player: " + str(player))
		row = convert_input_to_coordinate(int(input("Which row? (start with 1) ")))
		column = convert_input_to_coordinate(int(input("Which column? (start with 1) ")))
		game = add_piece(game, player, row, column)
		display_game(game)
		player = switch_player(player)</pre>
<p>After some modifications:</p>
<ul>
<li>to the game board drawing functions</li>
<li>adding a function to check the availability of a square</li>
<li>adding a function to check whether there are any moves available</li>
<li>updating the main game loop end condition</li>
</ul>
<p>The final product is here:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def draw_line(width, edge, filling):
	print(filling.join([edge] * (width + 1)))


def display_winner(player):
	if player == 0:
		print("Tie")
	else:
		print("Player " + str(player) + " wins!")

def check_row_winner(row):
	"""
	Return the player number that wins for that row.
	If there is no winner, return 0.
	"""
	if row[0] == row[1] and row[1] == row[2]:
		return row[0]
	return 0

def get_col(game, col_number):
	return [game[x][col_number] for x in range(3)]

def get_row(game, row_number):
	return game[row_number]

def check_winner(game):
	game_slices = []
	for index in range(3):
		game_slices.append(get_row(game, index))
		game_slices.append(get_col(game, index))

	# check diagonals
	down_diagonal = [game[x][x] for x in range(3)]
	up_diagonal = [game[0][2], game[1][1], game[2][0]]
	game_slices.append(down_diagonal)
	game_slices.append(up_diagonal)

	for game_slice in game_slices:
		winner = check_row_winner(game_slice)
		if winner != 0:
			return winner

	return winner

def start_game():
	return [[0, 0, 0] for x in range(3)]

def display_game(game):
	d = {2: "O", 1: "X", 0: "_"}
	draw_line(3, " ", "_")
	for row_num in range(3):
		new_row = []
		for col_num in range(3):
			new_row.append(d[game[row_num][col_num]])
		print("|" + "|".join(new_row) + "|")


def add_piece(game, player, row, column):
	"""
	game: game state
	player: player number
	row: 0-index row
	column: 0-index column
	"""
	game[row][column] = player
	return game

def check_space_empty(game, row, column):
	return game[row][column] == 0

def convert_input_to_coordinate(user_input):
	return user_input - 1

def switch_player(player):
	if player == 1:
		return 2
	else:
		return 1

def moves_exist(game):
	for row_num in range(3):
		for col_num in range(3):
			if game[row_num][col_num] == 0:
				return True
	return False

if __name__ == '__main__':
	game = start_game()
	display_game(game)
	player = 1
	winner = 0  # the winner is not yet defined

	# go on forever
	while winner == 0 and moves_exist(game):
		print("Currently player: " + str(player))
		available = False
		while not available:
			row = convert_input_to_coordinate(int(input("Which row? (start with 1) ")))
			column = convert_input_to_coordinate(int(input("Which column? (start with 1) ")))
			available = check_space_empty(game, row, column)
		game = add_piece(game, player, row, column)
		display_game(game)
		player = switch_player(player)
		winner = check_winner(game)
	display_winner(winner)</pre>
<p></p>
</figure>
</li>
</ul>