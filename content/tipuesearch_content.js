var tipuesearch = {"pages": [{'title': 'About', 'text': '整個學期下來，看見了很多以前在高中沒見過的東西，所以在做作業時偶爾會遇到一些問題，以為靠自己就能解決問題嗎?並沒有，所以不是去找大腿抱不然就是找老師問問題，如果自己硬要解決的話，可能只會越搞越糟糕而已，所以我要在這感謝那些曾經讓我抱過的大腿，當初github倉儲連接不到cmsimde的網站時就是請他們幫忙，如果沒請人幫忙的話可能現在連HW1都不會出現。 \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數. \n', 'tags': '', 'url': 'Develop.html'}, {'title': 'test', 'text': '', 'tags': '', 'url': 'test.html'}, {'title': 'HomeWork', 'text': '', 'tags': '', 'url': 'HomeWork.html'}, {'title': 'HW1', 'text': '', 'tags': '', 'url': 'HW1.html'}, {'title': 'Overview', 'text': '\xa0Expansion Slots \n \n Expansion cards are used to increase and expand a computer’s capability. \n 擴充卡用於增強和擴展計算機的功能 Communication-based cards can also expand the feature set of the computer through adding a modem or network card. 基於通信的卡還可以通過添加調製解調器或網卡來擴展計算機的功能集。 \n Users who want to play more games may find it useful to add a new video card with better graphics capabilities. \n 想要玩更多遊戲的用戶可能會發現添加具有更好圖形功能的新視頻卡很有用。 However, most commonly, expansion slots are used to add new ports and new features, such as ports and features that were initially unavailable when the computer was created, such as eSATA, FireWire, or USB 3.0 ports. 但是，最常見的是，擴展槽用於添加新端口和新功能，例如在創建計算機時最初不可用的端口和功能，例如eSATA，FireWire或USB 3.0端口。 \n \n \n \n PCI PCI-X Slots PCI was originally developed in the early 1990s to provide an expansion slot for network, video, audio, I O (input output), modem, and storage host adapter cards. PCI最初是在1990年代初開發的，旨在為網絡，視頻，音頻，I\xa0 \xa0O（輸入 輸出），調製解調器和存儲主機適配器卡提供擴展插槽。它取代了較早的技術，例如行業標準體系結構（ISA）卡，以提供更快，更強大的擴展卡插槽。 The subsequent upgrade is called PCI-X, which is a faster 64-bit version that runs at a bus speed of 133 MHz. 隨之而來的升級稱為PCI-X，它是一種更快的64位版本，以133 MHz的總線速度運行。 This PCI-X can be found in modern computers that still have PCI PCI-X slots. It is fully backward compatible with old PCI cards, but if you mix them with newer PCI-X cards, the motherboard defaults to Slower PCI speed 該PCI-X在仍然具有PCI\xa0 \xa0PCI-X插槽的現代計算機中可以找到，它與舊的PCI卡完全向後兼容，但是如果將它們與更新的PCI-X卡混合使用，則主板默認設置為較慢PCI速度 The latest version of PCI-X 2.0 supports speeds up to 266 MHz to 533 MHz, but has been replaced by the PCIe (PCI Express) card slot standard to achieve better speed performance. 最新版本的PCI-X 2.0支持最高266 MHz至533 MHz的速度，但已被PCIe（PCI Express）卡插槽標準所取代，以實現更好的速度 性能。 Since Apple Computers and AMD chipsets, it has been a standard expansion bus. Although PCI is definitely a traditional architecture, it has been replaced by PCIe and Thunderbolt interfaces, but it is still included in current motherboards and can be found in most computer workstation services. Apple Computers和AMD芯片組以來，一直是標準的擴展總線。儘管PCI絕對是一種傳統架構，但已被PCIe和Thunderbolt接口取代，但它仍包含在當前主板中，並且可以在大多數計算機工作站的服務中找到。 \n Summary The PCI bus operates independently of the system bus, so that expansion cards can be used to access peripheral devices faster. PCI總線獨立於系統總線運行，從而可以使用擴展卡更快地訪問外圍設備。 The PCI version initially uses a 32-bit data path and finally uses a 64-bit data path. The speed is as follows 133 MB s (32-bit, 33 MHz-standard configuration) 266 MB s (32-bit at 66 MHz or 64-bit at 33 MHz) 533 MB s (64-bit at 66 MHz) PCI版本最初使用32位數據路徑，最終使用64位數據路徑，速度如下 133 MB\xa0 \xa0s（32位，33 MHz –標準配置） 266 MB\xa0 \xa0s（66 MHz時為32位或33 MHz時為64位） 533 MB\xa0 \xa0s（66 MHz時為64位） \n \n \n', 'tags': '', 'url': 'Overview.html'}, {'title': 'AGP Slots (AGP插槽)', 'text': '\n AGP was dominant for a long period of time, but the introduction of PCIe (PCI express) ultimately led to a large decline in popularity, because PCIe speeds were able to outperform AGP and provide a singular slot type for all devices. \n AGP在很長一段時間內一直處於主導地位，但是PCIe（PCI Express）的引入最終導致了流行度的大幅下降，因為PCIe的速度能夠超過AGP並為所有設備提供單一的插槽類型。 \n Motherboards that provide AGP support have a single AGP slot. Several different versions of AGP have been implemented over the years \n AGP 1.0 1x\xa0 Runs at 66 MHz with a data throughput rate of 266 MBps. AGP 1.0 2x\xa0 Runs at 66 MHz with a data throughput rate of 533 MBps. AGP 2.0 4x\xa0 Runs at 66 MHz with a data throughput rate of 1066 MBps. AGP 3.0 8x\xa0 Runs at 66 MHz with a data throughput rate of 2133 MBps. \n 提供AGP支持的主機板有一個AGP插槽。這些年來，已經實現了AGP的幾種不同版本\n \n AGP 1.0 1x 以66 MHz運行，數據吞吐率為266 MBps。\nAGP 1.0 2x 以66 MHz運行，數據吞吐率為533 MBps。\nAGP 2.0 4x 以66 MHz運行，數據吞吐率為1066 MBps。\nAGP 3.0 8x 以66 MHz運行，數據吞吐率為2133 MBps。 \n PCI Express (PCIe) Expansion Slots \n PCIe (PCI express) began replacing PCI, PCI-X, and AGP by 2005. Five slot sizes are available for PCIe\xa0 x1, x2, x4, x8, and x16.\xa0 \n PCIe（PCI Express）到2005年開始取代PCI，PCI-X和AGP。PCIe有五個插槽大小可供選擇 x1，x2，x4，x8和x16。 \n \xa0PCIe x1 was designed to replace the old PCI cards for networking, modems, audio, input output, and other needs by connecting to the southbridge. \n PCIe x1旨在通過連接到南橋來替代用於網絡，調製解調器，音頻，輸入 輸出和其他需求的舊PCI卡。 It is worth noting that smaller PCIe cards can be placed in larger PCIe slots, and vice versa. For example, PCIe x2 can be inserted into PCIe x8, but PCIe x8 cannot be inserted into PCIe x2. 值得注意的是，較小的PCIe卡可以放入較大的PCIe插槽中，反之亦然。例如，PCIe x2可以插入 PCIe x8中，但PCIe x8不能插入PCIe x2中。 \n There are different versions of PCIe slots. The maximum number of channels that can be assigned to a card inserted in a slot depends on the version of the card. \xa0 PCIe插槽有不同版本。可以為插入插槽中的卡分配的最大通道數取決於卡的版本。 \n Basic PCIe provides one channel for transmission (x1) with a transmission rate of 250 MBps. It can also provide multiple transmission channels (x2, x4, x8, x16, x32). 基本PCIe提供一個通道用於傳輸（x1），傳輸速率為250 MBps。它還可以提供多個傳輸通道 （x2，x4，x8，x16，x32）。 \n Newer versions of PCIe can transfer data at an even higher rate per lane \n \n PCIe Version 1\xa0 250 MBps \n PCIe Version 2\xa0 500 MBps \n PCIe Version 3\xa0 1 Gbps \n PCIe Version 4\xa0 2 Gbps\n 較新版本的PCIe可以在每個通道上以更高的速率傳輸數據\n\nPCIe版本1 250 MBps\nPCIe版本2 500 MBps\nPCIe版本3 1 Gbps\nPCIe版本4 2 Gbps \n \n \n \n', 'tags': '', 'url': 'AGP Slots (AGP插槽).html'}, {'title': 'Processors(處理器)', 'text': 'Central processing unit is also called CPU or processor. The processor uses two main architectures 32-bit and 64-bit. We denote 32-bit processors (or applications designed \xa0 for these processors) as x86. 64-bit processors \xa0 and applications are represented as x64. \n 中央處理單元也稱為CPU或處理器。處理器採用兩種主要架構32位和64位。我們將32位處理器（或為這些處理器設計的應用程序）表示為x86。 64位處理器和應用程序表示為x64。 \n Three things can distinguish CPU types1) socket type (which CPU will fit which socket) 2) single-core or multi-core design 3) cache size. Although Intel and AMD are fully compatible in running Windows operating systems, if you are running UNIX Linux, you actually have to get the correct \xa0 software for your CPU type. \n 可以區分CPU類型的三件事1）套接字類型（哪個CPU將適合哪個套接字）\xa0 2）單核或多核設計\xa0 3）緩存的大小。儘管Intel和AMD在運行Windows操作系統方面是完全兼容的，但是如果您正在運行UNIX\xa0 \xa0Linux，則實際上必須為您的CPU類型獲得正確的軟件。 \n Intel has been making processors for a long time and their contemporary processors all use the land grid array (LGA) socket style. LGA uses spring-loaded “lands” that connect with the bottom of the processor and a hinged clamp mechanism to hold the processor onto the motherboard. The heat sink is then snapped into the mounting holes at the four corners of the processor socket. \n 英特爾長期以來一直在生產處理器，其現代處理器均使用陸地網格陣列（LGA）插槽樣式。 LGA使用彈簧加載的“平台”，該平台與處理器的底部連接，並通過鉸鍊式夾緊機構將處理器固定在主板上。然後將散熱器卡入處理器插槽四個角上的安裝孔。 \n \n Common Intel land grid arrays \n \n LGA 775 – Pentium 4, Pentium D, Celeron, Core 2 Duo, Core 2 Quad, Core 2 Extreme \n LGA 1366 – Core i7 9xx, Xeon series \n LGA 1156 – Core i3, Core i5, Core i7 (not 9xx) \n LGA 1155 – Sandy Bridge Core i3, Core i5, Core i7 (second-generation)\n 常見的英特爾陸地網格陣列 \n \n \n', 'tags': '', 'url': 'Processors(處理器).html'}, {'title': 'Video Displays and Video Cards(顯示器與顯示卡)', 'text': 'Earlier, we mentioned the various types of expansion cards\xa0now we are going to focus on video graphics cards. Video cards come in many varieties, and are sold under numerous different naming conventions, like graphics cards, graphics accelerator cards, or graphics adapters. These cards are add-on cards that create the images you see on the display monitor. They can come in a variety of expansion card types to fit into the various expansion slots, such as PCI express (PCIe) that is currently dominant, advanced graphics port (AGP), or the older PCI slots. While many low-end desktops come with an integrated graphics chip in the CPU instead of using a dedicated card, this is not suitable for 3D games or CAD CAM (computer-aided manufacturing) workstations. Therefore, many users will opt to use an add-on graphics card, like the one displayed below, to improve their gaming performance. \n \n 在前面，我們提到了各種類型的擴充卡。現在我們將專注於視頻 圖形卡。視頻卡種類繁多，並以 多種不同的命名約定出售，例如圖形卡，圖形加速卡或圖形適配器。這些卡是附加卡，可創建您 在顯示屏 監視器上看到的圖像。它們可以有多種擴展卡類型以適合各種擴展插槽，例如當前占 主導地位的PCI Express（PCIe），高級圖形端口（AGP）或較舊的PCI插槽。儘管許多低端台 式機都在CPU中集成了圖形芯片，而不是使用專用卡，但這不適用於3D遊戲或CAD CAM（計算 機輔助製造）工作站。因此，許多用戶將選擇使用附加的圖形卡（如下面顯示的圖形卡）來改善 其遊戲性能。 \n \n', 'tags': '', 'url': 'Video Displays and Video Cards(顯示器與顯示卡).html'}, {'title': 'Video Output', 'text': 'Video output comes in various types of connectors based on the motherboard’s chipset or the graphics card’s chipset. The standard that has been used for the past few decades is the VGA (video graphics adapter), which is a DB-15 style connector. VGA relies on providing a good-quality analog output to a traditional computer monitor. The port for this connector is the blue one on the left in the image below. \n \n \n 視頻輸出來自基於主板芯片組或圖形卡芯片組的各種類型的連接器。過去幾十年來一直使用的標 準是VGA（視頻圖形適配器），它是一種DB-15樣式的連接器。 VGA依靠向傳統的計算機顯示器 提供高質量的模擬輸出。該連接器的端口是下圖左側的藍色端口。 \n \n The next connector port, shown in white in the middle of the photo above, is called DVI, or digital video interface. It comes in DVI-D (for digital output only), or DVI-I (for integrated output that can provide digital or analog output) varieties. A DVI-I connector can be used with an adapter to operate with a traditional VGA monitor in analog mode, as well. \n \n 下一個連接器端口（稱為DVI或數字視頻接口），在上方的照片中間以白色顯示。它具有DVI-D （僅用於數字輸出）或DVI-I（用於可提供數字或模擬輸出的集成輸出）的品種。 DVI-I連接 器也可以與適配器一起使用，以在模擬模式下與傳統VGA顯示器一起使用。 \n \n The third connector, shown on the right of the image, is an HDMI, or high-definition multimedia interface, connection. HDMI comes with three standard connector type type A (standard), C (mini), and D (micro). Although there is a designation for a type B, it has not been adopted by any manufacturers at this time. Version 2.0 supports 4K UHD and HDR-enabled devices. Micro HDMI has been largely adopted by the mobile telephone market and is included on almost all current models. The special thing about HDMI is that it isn’t limited to carrying just video, but instead carries both audio and video over a single HDMI cable. HDMI is fully digital and doesn’t support analog displays. \n \n 圖像右側顯示的第三個連接器是HDMI或高清多媒體接口連接。 HDMI帶有三種標準連接器類 型 A型（標準），C型（微型）和D型（微型）。儘管有B型的名稱，但目前尚未被任何製造商採用。 2.0版支持支持4K UHD和HDR的設備。微型HDMI已被移動電話市場廣泛採用，並且幾乎包含在所 有當前型號中。 HDMI的特殊之處在於，它不僅限於承載視頻，還可以通過一根HDMI電纜同時傳 輸音頻和視頻。 HDMI是全數字的，不支持模擬顯示。 \n \n This makes it an ideal interface connector for laptops and mobile devices, similar to HDMI mini. It is also similar to HDMI in that it supports both video and audio with resolutions up to 3840x2160, which can support 4K UHD. DisplayPort can be found on IBM-clone (PC) machines and is gaining traction in the marketplace on mobile devices as well. \n 這使其成為筆記本電腦和移動設備的理想接口連接器，類似於HDMI mini。它也與HDMI類似， 它同時支持視頻和音頻，分辨率高達3840x2160，可以支持4K UHD。 DisplayPort可以在 IBM克隆（PC）機器上找到，並且在移動設備市場上也越來越受歡迎。 \n \n Component RGB (red green blue) is another high-definition connector type, but provides its output in analog format and only up to 720p of resolution. This was commonly used by VCR and DVD players, to connect to television sets, but can sometimes be found on older computers as a secondary output connector. Using RCA connectors, component video actually requires three connectors to pass the video signal to the TV, each one with a different colored label of red, green, and blue. Audio signals require separate patch cords. \n Component RGB（紅色，綠色，藍色）是另一種高清連接器類型，但以模擬格式提供其輸出， 並且分辨率最高僅為720p。 VCR和DVD播放器通常使用它來連接電視機，但有時可以在較舊的計 算機上找到它作為輔助輸出連接器。使用RCA連接器，分量視頻實際上需要三個連接器才能將視頻 信號傳遞到電視，每個連接器具有不同顏色的紅色，綠色和藍色標籤。音頻信號需要單獨的跳線。 \n \n', 'tags': '', 'url': 'Video Output.html'}, {'title': 'Install and Configure Expansion Cards(安裝和配置擴充卡)', 'text': 'In the lab below, you should install an expansion video card. Be sure to use proper ESD precautions so as to avoid damaging fragile components. \n 在下面的實驗室中，您應該安裝擴展視頻卡。確保使用正確的ESD預防措施，以避免損壞易碎的組件。 \n \n', 'tags': '', 'url': 'Install and Configure Expansion Cards(安裝和配置擴充卡).html'}, {'title': 'Storage Devices Overview(存儲設備概述)', 'text': 'USB flash drives are commonplace today and have replaced floppy disks as the removable media of choice. They are small in physical size and large in memory capability, with the ability to store 64 GB or more of data on a single “stick.” They are popular and easy to use, since they don’t require a special card reader, because the USB device has one built-in. They are often formatted with the FAT-16, FAT-32, or exFAT file system and are ready to use straight out of the box. Simply plug the device into an available USB port, the operating system recognizes it, and you can begin copying, deleting, and modifying files. \n USB閃存驅動器在當今很普遍，並且已取代軟盤作為首選的可移動介質。它們的物理尺寸 很小，內存容量也很大，能夠在單個“棒”上存儲64 GB或更多的數據。它們很受歡迎且 易於使用，因為它們不需要特殊的讀卡器，因為USB設備內置了一個。它們通常使用 FAT-16，FAT-32或exFAT文件系統進行格式化，並且可以直接使用。只需將設備插入 用的USB端口，操作系統即可識別它，然後您就可以開始復制，刪除和修改文件了。 \n Floppy disks dominated the removable storage arena until the late 1990s, and now they are nearly extinct in most organizations. While some removable USB thumb drives can store 64 GB or more of data, floppy disks usually only stored 1.44 MB of data. That means a single thumb drive can store the information from more than 60,000 floppy disks! Floppy disks used flexible magnetic media surrounded by a rigid plastic case. The most common floppy (shown in the bottom image) was the 3.5” floppy, which was named based on the diameter of the magnetic media inside the plastic case. It used to be commonplace to find a floppy disk drive on every computer, which was connected using a mini-molex or BERG power cable and a 34-pin internal IDE PATA cable. Contemporary machines typically do not have these drives, as they have fallen out of favor with the public. If you have a need for a floppy drive, one can be purchased for less than $20 that can connect to your computer using your USB port. Windows always reserves the A\xa0 and B\xa0 drives for the floppy disk drive (FDD), even if your system doesn’t have one. \n 直到1990年代後期，軟盤一直在可移動存儲領域佔據著主導地位，現在在大多數組織中它 們幾乎已經滅絕。雖然某些可移動USB拇指驅動器可以存儲64 GB或更多的數據，但是軟盤 通常僅存儲1.44 MB的數據。這意味著一個拇指驅動器可以存儲來自60,000多個軟盤的 信息！軟盤使用柔性磁性介質，並由剛性塑料盒包圍。最常見的軟盤（如左圖所示） 是3.5英寸的軟盤，它是根據塑料盒內部磁性介質的直徑來命名的。過去通常在每台計算機 上都找到軟盤驅動器，該軟盤驅動器是使用minimolex或BERG電源電纜以及34針內部 IDE\xa0 \xa0PATA電纜連接的。現代機器通常不具有這些驅動器，因為它們已受到公眾的青睞。 如果您需要軟盤驅動器，則可以用不到20美元的價格購買一個軟盤驅動器，它可以使用 USB端口連接到計算機。 Windows始終將A 和B 驅動器保留為軟盤驅動器（FDD）， 即使您的系統沒有該驅動器也是如此。 \n \n', 'tags': '', 'url': 'Storage Devices Overview(存儲設備概述).html'}, {'title': 'Storage Devices Hard Disk Drives(儲存設備 硬碟驅動器)', 'text': 'SSDs are intended to replace the traditional hard disk. They are fast and durable, and contain no moving parts. The SSD emulates a traditional hard drive and is often used in netbooks, Ultrabooks, and other lightweight systems, or machines that require fast, quiet performance. Most SSDs come in a 2.5-inch form factor, similar to a laptop hard disk, and use a 2.5-inch to 3.5-inch adapter when being placed in a desktop computer. The SSD can be built using multilevel cell (MLC) to save money, but these tend to be much slower than their more expensive and faster counterpart, the SLC (single level cell). Initially, these drives cost five to ten times as much as an equivalent-capacity traditional hard disk. Market demand and increased production have helped lower the pricing. As of the end of 2015, a 2.5-inch 250 GB SATAIII SSD can be purchased for less than $100, but the same amount of money would purchase a traditional 2 TB HDD. But, they are significantly faster and quieter, since they can access the information directly without having to wait for the hard disk to spin up and find the data on the disk. \n SSD旨在替代傳統硬盤。它們既快速又耐用，並且沒有活動部件。 SSD模仿傳統的硬盤驅動器，通常用於上網本，超極本和其他輕量級系統，或需要快速，安靜性能的機器中。大多數SSD的外形尺寸為2.5英寸，類似於筆記本電腦的硬盤，並且放在台式機中時使用2.5英寸至3.5英寸的適配器。可以使用多層單元（MLC）來構建SSD，以節省資金，但是這些SSD往往比價格更高，速度更快的同類產品SLC（單層單元）慢得多。最初，這些驅動器的成本是同等容量的傳統硬盤的五至十倍。市場需求和產量增加幫助降低了定價。截至2015年底，可以以不到100美元的價格購買2.5英寸250 GB SATAIII SSD，但以同樣的金額購買傳統的2 TB HDD。但是，它們可以更快，更安靜地運行，因為它們可以直接訪問信息，而不必等待硬盤啟動並在磁盤上查找數據。 Storage Devices Drive Interfaces(儲存設備 驅動器接口) \n SATA is the current connection method used for hard disks and optical drives. It is called serial because only a single device can be attached to each cable, and the data is transmitted in serial fashion (one bit at a time). These devices often do not have jumpers, but if they have one, it is used to configure the speed of data transfer or to enable a special feature like \xa0 spread spectrum clocking \xa0 . SATA is a peripheral device and is very fast, allowing for speeds of up to 6 Gbps for the newer version, or 3 Gbps for the older versions. The data cable is shaped like an L, with seven pins for data. The power cable is also L-shaped, but has 15 pins. Internal SATA ports can be converted to an eSATA (external SATA) port simply by using a header to connect the internal port. \n SATA是用於硬盤和光盤驅動器的當前連接方法。之所以稱為串行，是因為每條電纜只能連接一個設備，並且數據以串行方式（一次一位）傳輸。這些設備通常沒有跳線，但如果有跳線，則可用於配置數據傳輸速度或啟用特殊功能，例如擴頻時鐘。 SATA是外圍設備，速度非常快，新版本的速度高達6 Gbps，而舊版本的速度高達3 Gbps。數據電纜的形狀像L形，有七個用於數據傳輸的引腳。電源線也為L形，但有15針。只需使用接頭連接內部端口，即可將內部SATA端口轉換為eSATA（外部SATA）端口。 \n SCSI, or small computer system interface, supports daisy-chaining of devices (internally or externally) with either seven devices (narrow SCSI) or 15 devices (wide SCSI). Each device in the chain is provided with a Device ID number that is configured using a selector switch, DIP (dual inline package) switch, or jumper block. SCSI is an older technology and has largely been replaced by SATA and eSATA. Narrow SCSI could only support speeds of up to 40 MBps, while wide SCSI could support up to 320 MBps. \n SCSI或小型計算機系統接口支持將設備（內部或外部）與7個設備（窄SCSI）或15個設備（寬SCSI）進行菊花鏈連接。鏈中的每個設備都提供了一個設備ID編號，該ID使用選擇器開關， DIP（雙列直插式封裝）開關或跳線塊進行配置。 SCSI是一種較舊的技術，在很大程度上 已被SATA和eSATA取代。窄SCSI只能支持高達40 MBps的速度，而寬SCSI可以支持高達320 MBps的速度。 \n', 'tags': '', 'url': 'Storage Devices Hard Disk Drives(儲存設備 硬碟驅動器).html'}, {'title': 'Storage Devices\xa0 Hot Swapping(儲存設備 熱交換)', 'text': 'When desktops were originally developed, they weren’t designed to allow for hot-swapping of devices. Hot-swapping is the act of adding or removing a device while the computer is still turned on. In the old days, the user would shut the system down, power the workstation off, then connect the device, and turn the machine back on, otherwise the computer wouldn’t recognize the new device. In the late 1990s, the Windows operating system began to allow hot-swapping of devices, which included USB and FireWire. This allowed the user to simply plug in a device, wait a few seconds, and then begin using it to store or retrieve data. Due to this hot-swapping, it is important that users use the “eject drive safely” feature in Windows before unplugging a device, otherwise\xa0 data loss will occur . SATA eSATA also support hot-swapping, but only if AHCI (advanced host controller interface) is selected during configuration in the BIOS. If not, the drive will work as if it is an older PATA IDE device and will not support hot-swapping. \n 最初開發台式機時，它們的設計不允許熱插拔設備。熱交換是在計算機仍打開時添加或刪除設備的操作。在過去，用戶會關閉系統，關閉工作站電源，然後連接設備，然後重新啟動計算機，否則計算機將無法識別新設備。在1990年代後期，Windows操作系統開始允許熱插拔設備，包括USB和FireWire。這使用戶可以簡單地插入設備，等待幾秒鐘，然後開始使用它來存儲或檢索數據。由於這種熱交換，在拔出設備電源之前，用戶必須在Windows中使用“安全彈出驅動器”功能，這一點很重要，否則會導致數據丟失。SATA eSATA也支持熱插拔，但前提是在BIOS中配置期間選擇了AHCI（高級主機控制器接口）。否則，驅動器將像舊的PATA IDE設備一樣工作，並且不支持熱插拔。 \n', 'tags': '', 'url': 'Storage Devices\xa0 Hot Swapping(儲存設備 熱交換).html'}, {'title': 'Heat Sources(熱源)', 'text': '\xa0Heat is generated through thermal radiation as a by-product of electromagnetic movement within the circuits of our computers. The heat is caused by the internal resistance that the electricity encounters as it flows throughout the computer, and this resistance creates enough heat that the computer often becomes very, very hot inside the case. Each component of the computer creates heat at a different rate, depending on the specific operations being performed. For example, the CPU generates the most heat, since it does the greatest number of computations and uses a large amount of electricity. Another common source of heat is the graphics processing unit (GPU), which does an enormous amount of processing when performing calculations required to support 3D graphics, such as those used in video gaming. Often, during gaming, the GPU will actually create more heat than the CPU. \n 通過熱輻射產生的熱量是我們計算機電路內電磁運動的副產品。熱量是由電流在整個計算機中流動時 遇到的內部電阻引起的，並且該電阻產生的熱量足以使計算機在機殼內部變得非常非常熱。計算機的 每個組件都會以不同的速度產生熱量，具體取決於所執行的特定操作。例如，CPU產生的熱量最多， 因為它進行了大量的計算並消耗大量電能。另一個常見的熱量來源是圖形處理單元（GPU），當執行 支持3D圖形的計算時（例如視頻遊戲中使用的那些計算），它會進行大量處理。通常，在遊戲過程中， GPU實際上會比CPU產生更多的熱量。 Often there is no indication to the end user that an overheating condition is occurring, but even this can have severe consequences. Hard disk drives, CPUs, and GPUs are all sensitive to temperature changes. Hard drives in particular can become irreparably damaged by temperature changes due to the expansion and contraction of device components. This can cause read write errors, or even a complete failure of the disk drive. \n 通常，最終用戶沒有跡象表明發生了過熱情況，但即使這樣也會造成嚴重後果。硬盤驅動器， CPU和GPU都對溫度變化敏感。由於設備組件的膨脹和收縮，特別是硬盤驅動器會因溫度變化而造成不可挽回的損害。這可能導致讀 寫錯誤，甚至導致磁盤驅動器完全故障。 \n', 'tags': '', 'url': 'Heat Sources(熱源).html'}, {'title': 'heat reduction', 'text': 'There are many ways to reduce the amount of heat generated in a computer, but the most notable way is the use of a heat sink, like the one pictured below in green. A heat sink works to draw heat away from the sensitive components, such as the CPU, GPU, northbridge, and southbridge, through conduction. It then uses the fins to dissipate heat across a wider surface area. A fan usually moves air over the surface to remove the heat from the heat sink and push it out the computer’s exhaust vents on the back of the system. Heat sinks are created out of aluminum alloys or copper, which are soft metals with high heat conductivity. \n 有許多方法可以減少計算機中產生的熱量，但是最值得注意的方法是使用散熱器，如下面的綠色 圖片所示。散熱器通過傳導將熱量從敏感組件（例如CPU，GPU，北橋和南橋）吸走。然後，它使 用散熱片在更寬的表面積上散熱。風扇通常將空氣移動到表面上方，以從散熱器中散熱，然後將其 從系統背面的計算機排氣孔中推出。散熱器由鋁合金或銅製成，而鋁合金或銅是具有高導熱性的軟金屬。 \n \n', 'tags': '', 'url': 'heat reduction.html'}, {'title': 'BIOS Settings(bios設置)', 'text': 'Most modern motherboards and BIOS support temperature monitoring and control for the motherboard and its components. The name for this varies depending on manufacturer, but often it is called PC health or temperature monitoring. For motherboards that support overclocking, you can configure the settings in the BIOS to increase or decrease your processing capability, and thereby prevent additional heat from being generated. The CPU has a sensor that monitors its temperature, and the BIOS can increase or decrease the fan speed to control the temperature of the CPU. Remember, though, by reducing the power consumption (and therefore heat), you are also simultaneously reducing the performance of the CPU. \n 大多數現代主板和BIOS支持對主板及其組件進行溫度監控。其名稱因製造商而異，但通常稱為PC運行狀況或溫度監控。對於支持超頻的主板，您可以在BIOS中配置設置以增加或減少處理能力，從而防止產生更多的熱量。 CPU具有監視其溫度的傳感器，BIOS可以增加或減小風扇速度以控制CPU的溫度。但是請記住，通過減少功耗（並因此減少熱量），您同時也在降低CPU的性能。 \n', 'tags': '', 'url': 'BIOS Settings(bios設置).html'}, {'title': 'HW2', 'text': '', 'tags': '', 'url': 'HW2.html'}, {'title': '作業2-1', 'text': '參考40923211   方法一 : \n \n import urllib.request\n#導入urllib.request\ntarget_url = "https://nfulist.herokuapp.com/?semester=1091&courseno=0776"\n#設target_url = "網址"\ncp1b = []\n#設cp1b=數列\nfor line in urllib.request.urlopen(target_url):\n#重複打開target_url的迴圈定義line\n    cp1b.append(int(line.decode(\'utf-8\').rstrip()))\n    #把line重新編碼加進cp1b(數列)   註:rstrip()刪除字尾符號\nprint(cp1b)\n \n \n \n from random import shuffle #導入隨機洗牌\nlist  = [40523138,40523148,40723217,40728238,40823148,40823152,40923201,40923202,40923203,40923204,40923205,\n40923206,40923207,40923208,40923209,40923210,40923211,40923212,40923213,40923214,40923216,40923217,40923218,\n40923219,40923220,40923221,40923223,40923224,40923225,40923226,40923227,40923228,40923229,40923230,40923231,\n40923232,40923233,40923234,40923235,40923236,40923237,40923238,40923239,40923240,40923241,40923242,40923243,\n40923244,40923245,40923246,40923247,40923248,40923249,40923250,40923251,40923252,40923253] \n#列表[]\nshuffle(list) #shuffle=洗牌\nn=5\nm = int(len(list)/n) \nlist2 = [] \nfor i in range(0, len(list), m): #range()是一个函数， for i in range () 就是给i赋值： \n    list2.append(list[i:i+m]) \nprint(list2)  \n \n \n', 'tags': '', 'url': '作業2-1.html'}, {'title': '變數\xa0Variables', 'text': '', 'tags': '', 'url': '變數\xa0Variables.html'}, {'title': 'HTML Tutorial HTML教程', 'text': 'HTML Introduction HTML簡介 \n HTML is the standard markup language for creating Web pages. \n HTML是用於創建網頁的標準標記語言。 \n What is HTML? 什麼是HTML？ \n \n HTML stands for Hyper Text Markup Language \n HTML代表超文本標記語言 \n HTML is the standard markup language for creating Web pages \n HTML是用於創建網頁的標準標記語言 \n HTML describes the structure of a Web page \n HTML描述了網頁的結構 \n HTML consists of a series of elements \n HTML由一系列元素組成 \n HTML elements tell the browser how to display the content \n HTML元素告訴瀏覽器如何顯示內容 \n HTML elements label pieces of content such as "this is a heading", "this is a paragraph", "this is a link", etc. \n HTML元素標記內容的內容，例如“這是標題”，“這是段落”，“這是鏈接”等。 \n \n A Simple HTML Document 一個簡單的HTML文檔 \n Example 範例 \n <!DOCTYPE html>\n<html>\n<head>\n<title>Page Title</title>\n</head>\n<body>\n \n<h1>My First Heading</h1>\n<p>My first paragraph.</p>\n \n</body>\n</html> \n Example Explained 示例說明 \n \n The \xa0 <!DOCTYPE html> \xa0 declaration defines that this document is an HTML5 document \n <！DOCTYPE html>聲明定義此文檔為HTML5文檔 \n The \xa0 <html> \xa0 element is the root element of an HTML page \n <html>元素是HTML頁面的根元素 \n The \xa0 <head> \xa0 element contains meta information about the HTML page \n <head>元素包含有關HTML頁面的元信息 \n The \xa0 <title> \xa0 element specifies a title for the HTML page (which is shown in the browser\'s title bar or in the page\'s tab) \n <title>元素指定HTML頁面的標題（顯示在瀏覽器的標題欄中或頁面的選項卡中） \n The \xa0 <body> \xa0 element defines the document\'s body, and is a container for all the visible contents, such as headings, paragraphs, images, hyperlinks, tables, lists, etc. \n <body>元素定義文檔的正文，並且是所有可見內容的容器，例如標題，段落，圖像，超鏈接，表格，列表等。 \n The \xa0 <h1> \xa0 element defines a large heading \n <h1>元素定義一個大標題 \n The \xa0 <p> \xa0 element defines a paragraph \n <p>元素定義一個段落 \n \n What is an HTML Element? 什麼是HTML元素？ \n An HTML element is defined by a start tag, some content, and an end tag: \n HTML元素由開始標籤，一些內容和結束標籤定義： \n <tagname> Content goes here... </tagname> \n \n The HTML \xa0 element \xa0 is everything from the start tag to the end tag: \n HTML元素包括從開始標記到結束標記的所有內容： \n <h1> My First Heading </h1> \n \n <p> My first paragraph. </p> \n \n \n \n Note: \xa0 Some HTML elements have no content (like the <br> element). These elements are called empty elements. Empty elements do not have an end tag! \n 注意：某些HTML元素沒有內容（例如<br>元素）。這些元素稱為空元素。空元素沒有結束標籤！ \n Web Browsers 網頁瀏覽器 \n \n \n \n \n \n The purpose of a web browser (Chrome, Edge, Firefox, Safari) is to read HTML documents and display them correctly. \n 網絡瀏覽器（Chrome，Edge，Firefox，Safari）的目的是讀取HTML文檔並正確顯示它們。 \n A browser does not display the HTML tags, but uses them to determine how to display the document: \n 瀏覽器不顯示HTML標記，而是使用它們來確定如何顯示文檔： \n \n HTML Page Structure HTML頁面結構 \n \n Below is a visualization of an HTML page structure: \n 下面是HTML頁面結構的可視化： \n \n \n Note: \xa0 The content inside the <body> section (the white area above) will be displayed in a browser. The content inside the <title> element will be shown in the browser\'s title bar or in the page\'s tab. \n 注意：<body>部分（上面的白色區域）內的內容將在瀏覽器中顯示。 <title>元素內的內容將顯示在瀏覽器的標題欄中或頁面的選項卡中。 \n HTML History HTML歷史 \n Since the early days of the World Wide Web, there have been many versions of HTML: \n 自萬維網問世以來，已經有許多版本的HTML： \n \n \n This tutorial follows the latest HTML5 standard. \n 本教程遵循最新的HTML5標準。 \n \n \n \n', 'tags': '', 'url': 'HTML Tutorial HTML教程.html'}, {'title': 'HW3', 'text': '', 'tags': '', 'url': 'HW3.html'}, {'title': 'Check Tic Tac Toe', 'text': 'This exercise is Part 2 of 4 of the Tic Tac Toe exercise series. The other exercises are: \xa0 Part 1 , \xa0 Part 3 , and \xa0 Part 4 . \n As you may have guessed, we are trying to build up to a full tic-tac-toe board. However, this is significantly more than half an hour of coding, so we’re doing it in pieces. \n 您可能已經猜到了，我們正在努力建立完整的井字遊戲板。但是，這遠遠超過了半個小時的編碼，因此我們要分批進行。 \n \n \n Today, we will simply focus on checking whether someone has WON a game of Tic Tac Toe, not worrying about how the moves were made. \n 我們只關注檢查某人是否贏得了井字遊戲，而不用擔心這些動作是如何進行的。 \n \n If a game of Tic Tac Toe is represented as a list of lists, like so: \n \n game = [[1, 2, 0],\n\t[2, 1, 0],\n\t[2, 1, 1]] \n \n where a \xa0 0 \xa0 means an empty square, a \xa0 1 \xa0 means that player 1 put their token in that space, and a \xa0 2 \xa0 means that player 2 put their token in that space. \n Your task this week: given a 3 by 3 list of lists that represents a Tic Tac Toe game board, tell me whether anyone has won, and tell me which player won, if any. A Tic Tac Toe win is 3 in a row - either in a row, a column, or a diagonal. Don’t worry about the case where TWO people have won - assume that in every board there will only be one winner. \n 給定一個代表Tic Tac Toe遊戲板的3 x 3列表，請告訴我是否有人贏了，並告訴我哪 個玩家贏了（如果有）。井字遊戲的勝利是連續3個-連續，一列或對角線。不必擔心會 有兩個人獲勝的情況-假設在每個董事會中只有一個獲勝者。 \n Here are some more examples to work with: \n \n winner_is_2 = [[2, 2, 0],\n\t[2, 1, 0],\n\t[2, 1, 1]]\n\nwinner_is_1 = [[1, 2, 0],\n\t[2, 1, 0],\n\t[2, 1, 1]]\n\nwinner_is_also_1 = [[0, 1, 0],\n\t[2, 1, 0],\n\t[2, 1, 1]]\n\nno_winner = [[1, 2, 0],\n\t[2, 1, 0],\n\t[2, 1, 2]]\n\nalso_no_winner = [[1, 2, 0],\n\t[2, 1, 0],\n\t[2, 1, 0]] \n \n \n Topics \n This exercise is challenging, but doable with only lists (of lists)! Lists of lists are nearly the same as lists, just a bit trickier. Remember that to get the first element in a list called \xa0 my_list = [5, 10, 15] , you index it with a variable like so: \n 僅可使用列表中的列表！列表的列表與列表幾乎相同，只是比較棘手。請記住，要獲取 名為my_list = [5，10，15]的列表中的第一個元素，請使用如下所示的變量對其進 行索引： \n \n >>> print(my_list[0])\n\t5\n\t>>> print(my_list[-1])\n\t15\n\t>>> print(len(my_list))\n\t3 \n \n When working with lists of lists, it is the same! Say you have a list \xa0 matrix = [[1, 2], [3, 4]] . Then, take a look at this: \n \n >>> print(matrix[0])\n\t[1, 2]\n\t>>> print(matrix[-1])\n\t[3, 4]\n\t>>> first_row = matrix[0]\n\t>>> print(first_row[0])\n\t1\n\t>>> print(matrix[0][0])\n\t1\n\t>>> print(matrix[1][1])\n\t4 \n \n The cool part is that you can use double-indexing to read the elements from our list of lists \xa0 matrix ! By indexing \xa0 matrix[0][1] \xa0 we are saying give me the 1st element of the 0th element of \xa0 matrix , which in this case is \xa0 2 . 最酷的部分是您可以使用雙索引從列表列表矩陣中讀取元素！通過索引矩陣[0] [1]，我們要給我矩陣第0個元素的第一個元素，在這種情況下為2。 \n', 'tags': '', 'url': 'Check Tic Tac Toe.html'}, {'title': 'Max Of Three', 'text': "Implement a function that takes as input three variables, and returns the largest of the three. Do this without using the Python \xa0 max() \xa0 function! \n The goal of this exercise is to think about some internals that Python normally takes care of for us. All you need is some variables and \xa0 if \xa0 statements! \n Max Of Three Solutions \n Sample solutions \n There are many ways to answer this question, ranging from simple to complex. Here are a few reader-submitted answers! \n 有許多方法可以回答此問題，從簡單到復雜。這是讀者提交的一些答案！ \n This first example solution uses a series of \xa0 if \xa0 statements and comparisons to find the largest of 3 elements. \n def max_of_three(a,b,c):\n     max_3=0\n     if a>b:\n         #max_3=a\n         if a>c:\n             max_3=c\n         else:\n             max_3=a\n     else:\n          if b>c:\n             max_3=b\n          else:\n             max_3=c\n     return max_3 \n Another solution is a little bit less verbose, taking 3 numbers as an input, making them into a list, sorting them, and then reading off the largest element. \n 另一個解決方案是稍微冗長一些，將3個數字作為輸入，將它們放入列表，對它們進行排序，然後讀取最大的元素。 \n This last solution uses a more compact series of\xa0 if \xa0 statement comparisons to cover all cases of 3 elements. \n #!/usr/bin/env python\nimport sys\n\nif len(sys.argv) < 4:\n    print 'Usage <value1> <value2> <value3>'\n    sys.exit ( 1 )\n    \narg1 = sys.argv[1]\narg2 = sys.argv[2]\narg3 = sys.argv[3]\ndef maxfunction(a,b,c):\n\tif (a > b) and (a > c):\n\t    print 'Max value is :',a\n        elif (b > a) and (b > c):\n            print 'Max value is :',b\n        elif (c > a) and (c > b):\n            print 'Max value is :',c\n            \nmaxfunction(arg1,arg2,arg3) \n", 'tags': '', 'url': 'Max Of Three.html'}, {'title': 'Tic Tac Toe Game', 'text': 'Sample solution \n This exercise is unique because it relies on the output of the other exercises that need to be put together to make the final solution. The goal is to get practice with functions and how they work together in larger programs. \n 該練習是獨特的，因為它依賴於需要匯總以得出最終解決方案的其他練習的輸出。目的是練習功能以及它們如何在較大的程序中協同工作。 \n The 3 exercises above suggest breaking your Tic Tac Toe game into (at least) 4 functions: \n \n A function for drawing the game board (and the location of pieces) \n A function for checking whether there is a winner in the game \n A function for adding user input into the game state \n A main function that calls the others and plays the game \n \n The way to solve this problem is to look back at all 3 solutions to the previous exercises, copy them into one file, and modify what you had before. This is a different way of coding than coding an entire program from scratch, and can often save a lot of time. \n 解決此問題的方法是回顧一下先前練習的所有3個解決方案，將它們複製到一個文件中， 然後修改之前的內容。與從頭開始編寫整個程序相比，這是一種不同的編碼方式，通常 可以節省大量時間。 \n For my solution, I decided to copy all the functions from the older exercises into one file, and work from the main game logic from \xa0 Part 3 . Part 3 almost made you write the entire game - the main loop asking users for positions and input is already there, so starting from that point and modifying will let you finish this exercise in 30 minutes! \n Here is what my code looks like after copying in my solutions to \xa0 Part 1 , \xa0 Part 2 , and \xa0 Part 3 \xa0 of this exercise: \n def draw_line(width, edge, filling):\n\tprint(filling.join([edge] * (width + 1)))\n\ndef draw_board(width, height):\n\tdraw_line(width, " ", "__")\n\tfor i in range(height):\n\t\tdraw_line(width, "|", "__")\n\tprint("\\n")\n\ndef display_winner(player):\n\tif player == 0:\n\t\tprint("Tie")\n\telse:\n\t\tprint("Player " + str(player) + " wins!")\n\ndef check_row_winner(row):\n\t"""\n\tReturn the player number that wins for that row.\n\tIf there is no winner, return 0.\n\t"""\n\tif row[0] == row[1] and row[1] == row[2]:\n\t\treturn row[0]\n\treturn 0\n\ndef get_col(game, col_number):\n\treturn [game[x][col_number] for x in range(3)]\n\ndef get_row(game, row_number):\n\treturn game[row_number]\n\ndef check_winner(game):\n\tgame_slices = []\n\tfor index in range(3):\n\t\tgame_slices.append(get_row(game, index))\n\t\tgame_slices.append(get_col(game, index))\n\n\t# check diagonals\n\tdown_diagonal = [game[x][x] for x in range(3)]\n\tup_diagonal = [game[0][2], game[1][1], game[2][0]]\n\tgame_slices.append(down_diagonal)\n\tgame_slices.append(up_diagonal)\n\n\tfor game_slice in game_slices:\n\t\twinner = check_row_winner(game_slice)\n\t\tif winner != 0:\n\t\t\tdisplay_winner(winner)\n\t\t\treturn winner\n\n\tdisplay_winner(winner)\n\treturn winner\n\ndef start_game():\n\treturn [[0, 0, 0] for x in range(3)]\n\ndef display_game(game):\n\td = {2: "O", 1: "X", 0: " "}\n\tgame_string = []\n\tfor row_num in range(3):\n\t\tnew_row = []\n\t\tfor col_num in range(3):\n\t\t\tnew_row.append(d[game[row_num][col_num]])\n\t\tgame_string.append(new_row)\n\tprint(game_string)\n\n\ndef add_piece(game, player, row, column):\n\t"""\n\tgame: game state\n\tplayer: player number\n\trow: 0-index row\n\tcolumn: 0-index column\n\t"""\n\tgame[row][column] = player\n\treturn game\n\ndef convert_input_to_coordinate(user_input):\n\treturn user_input - 1\n\ndef switch_player(player):\n\tif player == 1:\n\t\treturn 2\n\telse:\n\t\treturn 1\n\n\nif __name__ == \'__main__\':\n\tgame = start_game()\n\tdisplay_game(game)\n\tplayer = 1\n\n\t# go on forever\n\twhile True:\n\t\tprint("Currently player: " + str(player))\n\t\trow = convert_input_to_coordinate(int(input("Which row? (start with 1) ")))\n\t\tcolumn = convert_input_to_coordinate(int(input("Which column? (start with 1) ")))\n\t\tgame = add_piece(game, player, row, column)\n\t\tdisplay_game(game)\n\t\tplayer = switch_player(player) \n After some modifications: \n \n to the game board drawing functions \n adding a function to check the availability of a square \n adding a function to check whether there are any moves available \n updating the main game loop end condition \n \n The final product is here: \n def draw_line(width, edge, filling):\n\tprint(filling.join([edge] * (width + 1)))\n\n\ndef display_winner(player):\n\tif player == 0:\n\t\tprint("Tie")\n\telse:\n\t\tprint("Player " + str(player) + " wins!")\n\ndef check_row_winner(row):\n\t"""\n\tReturn the player number that wins for that row.\n\tIf there is no winner, return 0.\n\t"""\n\tif row[0] == row[1] and row[1] == row[2]:\n\t\treturn row[0]\n\treturn 0\n\ndef get_col(game, col_number):\n\treturn [game[x][col_number] for x in range(3)]\n\ndef get_row(game, row_number):\n\treturn game[row_number]\n\ndef check_winner(game):\n\tgame_slices = []\n\tfor index in range(3):\n\t\tgame_slices.append(get_row(game, index))\n\t\tgame_slices.append(get_col(game, index))\n\n\t# check diagonals\n\tdown_diagonal = [game[x][x] for x in range(3)]\n\tup_diagonal = [game[0][2], game[1][1], game[2][0]]\n\tgame_slices.append(down_diagonal)\n\tgame_slices.append(up_diagonal)\n\n\tfor game_slice in game_slices:\n\t\twinner = check_row_winner(game_slice)\n\t\tif winner != 0:\n\t\t\treturn winner\n\n\treturn winner\n\ndef start_game():\n\treturn [[0, 0, 0] for x in range(3)]\n\ndef display_game(game):\n\td = {2: "O", 1: "X", 0: "_"}\n\tdraw_line(3, " ", "_")\n\tfor row_num in range(3):\n\t\tnew_row = []\n\t\tfor col_num in range(3):\n\t\t\tnew_row.append(d[game[row_num][col_num]])\n\t\tprint("|" + "|".join(new_row) + "|")\n\n\ndef add_piece(game, player, row, column):\n\t"""\n\tgame: game state\n\tplayer: player number\n\trow: 0-index row\n\tcolumn: 0-index column\n\t"""\n\tgame[row][column] = player\n\treturn game\n\ndef check_space_empty(game, row, column):\n\treturn game[row][column] == 0\n\ndef convert_input_to_coordinate(user_input):\n\treturn user_input - 1\n\ndef switch_player(player):\n\tif player == 1:\n\t\treturn 2\n\telse:\n\t\treturn 1\n\ndef moves_exist(game):\n\tfor row_num in range(3):\n\t\tfor col_num in range(3):\n\t\t\tif game[row_num][col_num] == 0:\n\t\t\t\treturn True\n\treturn False\n\nif __name__ == \'__main__\':\n\tgame = start_game()\n\tdisplay_game(game)\n\tplayer = 1\n\twinner = 0  # the winner is not yet defined\n\n\t# go on forever\n\twhile winner == 0 and moves_exist(game):\n\t\tprint("Currently player: " + str(player))\n\t\tavailable = False\n\t\twhile not available:\n\t\t\trow = convert_input_to_coordinate(int(input("Which row? (start with 1) ")))\n\t\t\tcolumn = convert_input_to_coordinate(int(input("Which column? (start with 1) ")))\n\t\t\tavailable = check_space_empty(game, row, column)\n\t\tgame = add_piece(game, player, row, column)\n\t\tdisplay_game(game)\n\t\tplayer = switch_player(player)\n\t\twinner = check_winner(game)\n\tdisplay_winner(winner) \n \n', 'tags': '', 'url': 'Tic Tac Toe Game.html'}]};